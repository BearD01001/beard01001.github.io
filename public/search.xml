<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[优化 macOS Stage Manager 开启后新开窗口后屏幕左侧有空隙的问题]]></title>
      <url>%2FmacOS%2F%E4%BC%98%E5%8C%96-macOS-Stage-Manager-%E5%BC%80%E5%90%AF%E5%90%8E%E6%96%B0%E5%BC%80%E7%AA%97%E5%8F%A3%E5%90%8E%E5%B1%8F%E5%B9%95%E5%B7%A6%E4%BE%A7%E6%9C%89%E7%A9%BA%E9%9A%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[macOS 中的 Stage Manager 提供了一种高效的窗口管理方式，使用户能够轻松组织和切换应用程序窗口。然而，当开启 Stage Manager 功能后，即使关闭了”Show recent apps in Stage Manager”选项，新创建的最大化应用窗口仍会在屏幕左侧留下一个小间隙。这篇文章将介绍如何通过命令行工具来彻底消除该间隙，从而优化应用程序窗口最大化的体验。 问题描述在启用 Stage Manager 后，即使关闭了显示最近使用应用的选项，新创建的最大化应用窗口仍会在屏幕左侧留有一个细小的间隙。如下图所示： 解决方案可以通过在终端中输入特定的命令来关闭这个多余的间隙，该命令通过更改系统设置来实现。 一、打开终端首先，需要打开终端应用程序。可以通过以下几种方式打开终端： 使用 Spotlight 搜索：按下 Command + Space，输入 “Terminal”，然后按下 Return 键。 通过 Finder：前往 Applications &gt; Utilities &gt; Terminal。 二、输入命令在终端中输入以下命令，并按下 Return 键： 1defaults write com.apple.WindowManager StageFrameMinimumHorizontalInset -int 0 最后的 0 可以调整为 [-2147483647…2147483647] 之间的任意整数 三、重启 Stage Manager 或者重启电脑输入完成后，可能需要重启 Stage Manager 或者重启电脑以使更改生效。 不过我这边是即时生效的。 效果验证执行上述命令并重启系统或 Stage Manager 后，新创建的最大化应用窗口将不会再在屏幕左侧留下间隙。如下图所示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[笔记] 当在 Vue 中不得不用全局样式时...]]></title>
      <url>%2FNote%2F%E7%AC%94%E8%AE%B0-%E5%BD%93%E5%9C%A8-Vue-%E4%B8%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E6%97%B6%2F</url>
      <content type="text"><![CDATA[有时候基于 Vue 的单文件组件开发项目时, 不得不使用全局样式, 这时有一些需要注意的地方. 当遇到需要使用全局样式时, 下列几种情况 样式在项目各处均有使用; 样式只在当前组件内的 DOM 上使用; 样式需要应用到当前组件 DOM 的外部 DOM; 下面详细记录一下需要注意的问题: 样式在项目各处均有使用如果样式需要在项目各处均有使用, 例如: reset.css, tiny-trim.css 等等.这时推荐在项目入口文件中直接导入样式文件: 1234// src/main.jsimport 'tiny-trim.css'import 'asset/reset.css'import 'asset/global.css' 当然, 也可以在顶层组件中没有设置 scoped 属性的 style 标签中导入: 12@import url(asset/reset.css);@import url(asset/global.css); 样式只在当前组件内的 DOM 上使用当使用一些第三方 UI 库时, 有一些 UI 库生成的 DOM 在 template 中并不能直接添加 class 或 style 来修改第三方 UI 库的组件样式, 这时我们可以通过当前组件没有 scoped 属性的 style 标签来添加全局样式. 但此时需要考虑一些问题: 这个样式应该只影响当前组件内第三方 UI 库渲染出来的 DOM 因为 DOM 不在 template 标签里 (DOM 由第三方 UI 库的 JS 在浏览器加载时构建或在编译打包过程中生成), 不能直接设置 class 或 style 来修改样式, 故只能使用没有 scoped 属性的 style 标签 可以看出两点是有一定矛盾的. 不过可以采用如下方法解决或缓解: 为当前组件根元素设置自定义 data 属性 123456&lt;!-- src/components/MyComponent.vue --&gt;&lt;template&gt; &lt;div class="my-component" data-custom-mycomponent&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/tempalte&gt; 在没有 scoped 属性的 style 标签中使用自定义 data 属性限定样式作用域 123.my-component[data-custom-mycomponent] &#123; // ...&#125; 这里推荐使用 Less 或 Sass, 嵌套语法能减少许多代码冗余. 样式需要应用到当前组件 DOM 的外部 DOM这种情况主要是针对上一种情况的补充, 有时候第三方 UI 库生成的 DOM 节点并不在当前组件的 DOM 内, 可能渲染到 body 中 (如 dialog, tooltip, message 等). 这些渲染到当前组件 DOM 之外的组件, 需要在上一种情况的处理基础上, 为它们的顶层元素再设置一个自定义的 data 属性: 12345678910&lt;!-- src/components/MyComponent.vue --&gt;&lt;template&gt; &lt;div class="my-component" data-custom-mycomponent&gt; &lt;!-- message 组件的 DOM 将被渲染到 body 中, 而不是当前组件 .my-component 中 --&gt; &lt;message class="my-component-message" msg="You got a message! " data-custom-mycomponent-message /&gt; &lt;/div&gt;&lt;/tempalte&gt; 123456.my-component[data-custom-mycomponent] &#123; // ...&#125;.my-component-message[data-custom-mycomponent-message] &#123; // ...&#125; -EOF]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深度定制团队自己的 Vue template]]></title>
      <url>%2FJavaScript%2F%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E5%9B%A2%E9%98%9F%E8%87%AA%E5%B7%B1%E7%9A%84-Vue-template%2F</url>
      <content type="text"><![CDATA[众所周知，使用 vue-cli 可以快速初始化一个基于 Vue.js 的项目，官方提供了 webpack、pwa、browserify-simple 等常用 templates。 当开发一个独立项目的时候，使用官方提供的 template 确实非常方便，省去了繁琐的依赖安装配置、webpack 配置，甚至连项目结构也不用多加考虑。 但是，当我们需要开发多个系统，每个系统相对独立但又有一些配置、依赖或逻辑相互通用的时候（例如集群的多后台系统），每次使用官方提供的 template 初始化项目之后，都需要进一步调整（添加依赖、修改配置、增加通用组件等等），这显然是十分麻烦的。本着懒惰是第一生产力的初衷，我们需要定制一份自己的 template，以便我们…额…偷懒哈~ 在开始定制我们自己的 Vue template 前，我们需要了解一些前置知识： 前置知识 模板结构 首先我们先来了解模板的主要结构，模板结构很简单，主要包括两个部分： template 该目录用于存放模板文件，初始化项目生成的文件来自于此。 meta.js / meta.json 用于描述初始化项目时命令行的交互动作。 Metalsmith Metalsmith 在渲染项目文件流程中角色相当于 gulp.js，可以通过添加一些插件对构建文件进行处理，如重命名、合并等。 download-git-repo 使用 vue-cli 初始化项目时会使用该工具来下载目标仓库。默认的 webpack 等模板直接下载 vue-templates 中对应的模板仓库。 自定义的模板也可以是一个 GitHub 仓库，使用如下命令来初始化项目： 1vue init username/repo my-project 其中 username 为自定义模板仓库所在的 GitHub 用户或组织名，repo 为仓库名。 Inquirer.js vue-cli 在模板仓库下载完成后，将通过 Inquirer.js 根据模板仓库中的 meta.js 或 meta.json 文件中的设置，与用户进行一些简单的交互以确定项目的一些细节，如下图： 该交互配置是可选的，当项目中没有 meta.js 或 meta.json 文件时，模板仓库下载完成后将直接进入模板构建阶段。 Handlebars.js 在通过命令行交互确定了项目初始化的细节后，就该进入最后一道工序，按照模板初始化我们的项目啦！\(≧▽≦)/ 这里 vue-cli 选用的是 Handlebars.js —— 一个简单高效的语义化模板构建引擎。 画了一张图，更有助于理清这些依赖在 vue-cli 初始化项目时的相互关联： 定制模板主要围绕着命令行交互（Inquirer.js）与模板文件开发（Handlebars.js）这两部分。 meta.js 配置文件（Inquirer.js） 由于 meta.js 相当于模板项目的配置文件（虽然非必选），所以这里先看看它主要能干些啥。 设置都在 meta.js 或 meta.json 中配置，推荐使用 meta.js，更灵活一些。以下也将以 meta.js 进行展开说明。 meta.js 一共可包含如下几个字段，简单列一下各字段功能： helpers : 自定义 Handlebars.js 的辅助函数 prompts : 基于 Inquirer.js 的命令行交互配置 filters : 根据命令行交互的结果过滤将要渲染的项目文件 metalsmith : 配置 Metalsmith 插件，文件会像 gulp.js 中的 pipe 一样依次经过各个插件处理 completeMessage : 将模板渲染为项目后，输出一些提示信息，取值为字符串 complete : 与 completeMessage 功能相同，二选其一，取值为函数，函数最后需返回输出的字符串 命令行交互（Inquirer.js） 命令行交互主要是 meta.js 中 prompts 字段的配置，详细的配置可以阅读 Inquirer.js 的 README.md，这里说一下常用的交互配置：12345678910111213141516171819202122// meta.jsmodule.export = &#123; // ... "prompts": &#123; "isCustomName": &#123; "type" : "confirm", "message": "是否自定义系统名称？", &#125;, "sysName": &#123; "type" : "input", "when" : "isCustomName", "default" : "默认系统名称", "message" : "请输入系统名称:", "required": true, "validate": function (val) &#123; if (!val) return '(✘) 请输入系统名称，该名称将设为 index.html 的 title'; return true; &#125;, &#125;, // ... &#125;,&#125; 字段说明： isCustomName 与 sysName : 交互字段名称，可在后续条件交互或模板渲染时通过该字段读取到交互结果 type : 交互类型，有 input, confirm, list, rawlist, expand, checkbox, password, editor 八种类型 message : 交互的提示信息 when : 进行该条件交互的先决条件，在该例子中，sysName 这个交互动作只在 isCustomName 交互结果为真时才会出现 default : 默认值，当用户输入为空时，交互结果即为此值 required : 默认为 false，该值是否为必填项 validate : 输入验证函数 注：示例中 default required validate 三个字段存在逻辑问题，仅为举例方便放到一起。 模板基本语法（Handlebars.js） 在模板编写中，我们可以用 Mustache 语法在任何文本类型的文件中输出在命令行交互中得到的一些数据：123456// dev.jsexport default &#123; //... token: '&#123;&#123;token&#125;&#125;', //...&#125;; 12345678&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;sysName&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;!-- ... --&gt;&lt;/html&gt; 以 {{xxx}} 即为一个 Mustache 句法标记。以上例子中 token 与 sysName 为匹配命令行交互数据对应的键名。 对 vue 有过了解的都知道，在模板标签中直接输出实例上的数据也是用的 Mustache 语法。如果定制 vue template 模板时不对这些数据做相应处理，在最终输出由模板初始化的项目时，这些与命令行交互得到的数据无法匹配的 Mustache 句法标记会被移除。此时我们需要使用反斜杠 \{{xxx}} 或者 {{{xxx}}} 来跳过 Handlebars 的处理，直接输出 {{xxx}} 模板渲染时的辅助函数（Handlebars.js） vue-cli 中为 Handlebars 预置了 if_eq 与 unless_eq 辅助函数，用于使用交互所得数据来处理模板中是否渲染的两种逻辑关系，此外 Handlebars 中还内置了 if、unless、each 等 辅助函数。1234567// sys.jsexport default &#123; &#123;&#123;#if_eq projType 'admin'&#125;&#125; id: &#123;&#123;#if_eq sysId ''&#125;&#125;undefined&#123;&#123;else&#125;&#125;&#123;&#123;sysId&#125;&#125;&#123;&#123;/if_eq&#125;&#125;, &#123;&#123;/if_eq&#125;&#125; name: '&#123;&#123;sysName&#125;&#125;',&#125;; 如上，这里用了 if_eq 辅助函数，projType 代表将要匹配的键，&#39;admin&#39; 代表将要匹配的值。这个键值来自于在命令行界面与用户交互的操作结果。该栗子中，当命令行交互数据中 CLI[projType] == &#39;admin&#39; 时，将在 sys.js 文件的导出数据中输出 id 字段；id 的值来自一个嵌套的 if_eq 辅助函数，当 CLI[sysId] == &#39;&#39; 时，id 将被设置为 undefined 否则 （{{else}}）输出 CLI[sysId] 命令行交互所得数据中的 sysId。 辅助函数使用语法： {{{%endraw%}# + 函数名 + ‘ ‘（空格）+ 以空格分隔的参数列表 + }}以空格分隔的参数列表：未用引号包裹的参数名将被将为自动取值为命令行交互结果中对应的数据 自定义辅助函数（Handlebars.js） 有时候现有的辅助函数可能不能满足我们的需求，通过 mate.js 中的 helpers 字段我们可以自定义辅助函数：123456789101112// mate.jsmodule.exports = &#123; "helpers": &#123; "neither": function (k, v1, v2, options) &#123; if (k !== v1 &amp;&amp; k !== v2) &#123; return options.fn(this); &#125; return options.inverse(this); &#125;, &#125;, //...&#125; 辅助函数可以接受若干的参数，最后一个参数 options 为辅助函数的钩子，调用 options.fn(this) 即输出该辅助函数运算结果为真时的内容，反之调用 options.inverse(this) 则输出 {%raw%}{{else}} 的内容（如果有的话）。 现在我们可以在模板中直接使用 neither 辅助函数了：123456&#123;&#123;#neigher sysType 'admin' 'mobile'&#125;&#125;isAdmin = falseisMobile = false&#123;&#123;else&#125;&#125;isAdminOrMobile = true&#123;&#123;/neigher&#125;&#125; 按条件过滤渲染文件 辅助函数只可以控制文件内一部分内容的输出与否，有时候我们需要根据交互结果控制某些文件本身是否输出。 在 mate.js 中的 filters 字段中进行相应的设置，就可以达到控制文件输出的效果：12345678module.exports = &#123; //... "filters": &#123; "project/config/test.env.js": "unit || e2e", "project/src/router/**/*": "router" &#125;, //...&#125; filters 中键名是要控制输出的文件的路径，可使用字面量，也可使用 简化的 glob 表达式。键名对应的值为命令行交互中得到的数据。 渲染时文件的操作 在模板项目比较复杂或是有特殊需求的时候，比如： 按照条件不同需要渲染两个文件名相同但内容完全不同的文件 模板模块化，多个模板文件拼接渲染为一个项目文件 使用 GZip 压缩一些非源码资源 可以通过 mate.js 中的 metalsmith 字段配置相关插件来实现丰富的文件操作：1234567891011121314151617181920var renamer = require('metalsmith-renamer')module.exports = &#123; //... "metalsmith": function(metalsmith, opts, helpers) &#123; metalsmith.use(renamer(&#123; index: &#123; pattern: 'project/**/+(Mobile|Admin)Index.vue', rename: function(fileName) &#123; return 'Index.vue'; &#125; &#125;, config: &#123; pattern: 'project/src/+(mobile|admin)Config.js', rename: 'config.js' &#125;, //... &#125;)) &#125;, //...&#125; 以上是 metalsmith-renamer 插件的简单使用，更多插件可以在这里查找 使用 metalsmith 插件请注意：由于 vue-cli 在下载完成模板仓库后并没有 npm install 安装模板的项目依赖这一操作，所以在打包模板仓库的时候也需要将依赖目录 node_modules 一同打包，metalsmith 的插件都很精简，一般不会有什么嵌套依赖。不过还是建议在使用前查看一下插件的相关 Github 仓库。 关于 vue 项目模板的开发涉及到的问题差不多就介绍完了，为自己或团队开发一份专属的 Vue Template 吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VueJS 开发常见问题集锦]]></title>
      <url>%2FJavaScript%2FVueJS-%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
      <content type="text"><![CDATA[由于公司的前端开始转向 VueJS，最近开始使用这个框架进行开发，遇到一些问题记录下来，以备后用。 主要写一些 官方手册 上没有写，但是实际开发中会遇到的问题，需要一定知识基础。 涉及技术栈 CLI: Vue-CLI UI: Element HTML: Pug(Jade) CSS: Less JavaScript: ES6 正文： polyfill 与 transform-runtime 首先，vue-cli 为我们自动添加了 babel-plugin-transform-runtime 这个插件，该插件多数情况下都运作正常，可以转换大部分 ES6 语法。 但是，存在如下两个问题： 异步加载组件时，会产生 polyfill 代码冗余 不支持对全局函数与实例方法的 polyfill 两个问题的原因均归因于 babel-plugin-transform-runtime 采用了沙箱机制来编译我们的代码（即：不修改宿主环境的内置对象）。 由于异步组件最终会被编译为一个单独的文件，所以即使多个组件中使用了同一个新特性（例如：Object.keys()），那么在每个编译后的文件中都会有一份该新特性的 polyfill 拷贝。如果项目较小可以考虑不使用异步加载，但是首屏的压力会比较大。 不支持全局函数（如：Promise、Set、Map），Set 跟 Map 这两种数据结构应该大家用的也不多，影响较小。但是 Promise 影响可能就比较大了。 不支持实例方法（如：&#39;abc&#39;.includes(&#39;b&#39;)、[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].find((n) =&gt; n &lt; 2) 等等），这个限制几乎废掉了大部分字符串和一半左右数组的新特性。 一般情况下 babel-plugin-transform-runtime 能满足大部分的需求，当不满足需求时，推荐使用完整的 babel-polyfill。 替换 babel-polyfill 首先，从项目中移除 babel-plugin-transform-runtime 卸载该依赖：1npm un babel-plugin-transform-runtime -D 修改 babel 配置文件12345678// .babelrc&#123; //... "plugins": [ // - "transform-runtime" ] //...&#125; 然后，安装 babel-polyfill 依赖：1npm i babel-polyfill -D 最后，在入口文件中导入12// src/main.jsimport 'babel-polyfill' ES6 import 引用问题 在 ES6 中，模块系统的导入与导出采用的是引用导出与导入（非简单数据类型），也就是说，如果在一个模块中定义了一个对象并导出，在其他模块中导入使用时，导入的其实是一个变量引用（指针），如果修改了对象中的属性，会影响到其他模块的使用。 通常情况下，系统体量不大时，我们可以使用 JSON.parse(JSON.stringify(str)) 简单粗暴地来生成一个全新的深度拷贝的 数据对象。不过当组件较多、数据对象复用程度较高时，很明显会产生性能问题，这时我们可以考虑使用 Immutable.js。 鉴于这个原因，进行复杂数据类型的导出时，需要注意多个组件导入同一个数据对象时修改数据后可能产生的问题。此外，模块定义变量或函数时即便使用 let 而不是 const，在导入使用时都会变成只读，不能重新赋值，效果等同于用 const 声明。 在 Vue 中使用 Pug 与 Less安装依赖 Vue 中使用 vue-loader 根据 lang 属性自动判断所需要的 loader，所以不用额外配置 Loader，但是需要手动安装相关依赖：12npm i pug -Dnpm i less-loader -D 还是相当方便的，不用手动修改 webpack 的配置文件添加 loader 就可以使用了 使用 pug 还是 pug-loader？sass 两种语法的 loader 如何设置？— 请参考 预处理器 · vue-loader 使用123456789101112131415161718192021222324252627&lt;!-- xxx.vue --&gt;&lt;style lang="less"&gt; .action &#123; color: #ddd; ul &#123; overflow: hidden; li &#123; float: left; &#125; &#125; &#125;&lt;/style&gt;&lt;template lang="pug"&gt; .action(v-if='hasRight') ul li 编辑 li 删除&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; hasRight: true &#125; &#125; &#125;&lt;/script&gt; 定义全局函数或变量 许多时候我们需要定义一些全局函数或变量，来处理一些频繁的操作（这里拿 AJAX 的异常处理举例说明）。但是在 Vue 中，每一个单文件组件都有一个独立的上下文（this）。通常在异常处理中，需要在视图上有所体现，这个时候我们就需要访问 this 对象，但是全局函数的上下文通常是 window，这时候就需要一些特殊处理了。 简单粗暴型 最简单的方法就是直接在 window 对象上定义一个全局方法，在组件内使用的时候用 bind、call 或 apply 来改变上下文。 定义一个全局异常处理方法：12345678// errHandler.jswindow.errHandler = function () &#123; // 不能使用箭头函数 if (err.code &amp;&amp; err.code !== 200) &#123; this.$store.commit('err', true) &#125; else &#123; // ... &#125;&#125; 在入口文件中导入：12// src/main.jsimport 'errHandler.js' 在组件中使用：1234567891011121314151617// xxx.vueexport default &#123; created () &#123; this.errHandler = window.errHandler.bind(this) &#125;, method: &#123; getXXX () &#123; this.$http.get('xxx/xx').then((&#123; body: result &#125;) =&gt; &#123; if (result.code === 200) &#123; // ... &#125; else &#123; this.errHandler(result) &#125; &#125;).catch(this.errHandler) &#125; &#125;&#125; 优雅安全型 在大型多人协作的项目中，污染 window 对象还是不太妥当的。特别是一些比较有个人特色的全局方法（可能在你写的组件中几乎处处用到，但是对于其他人来说可能并不需要）。这时候推荐写一个模块，更优雅安全，也比较自然，唯一不足之处就是每个需要使用该函数或方法的组件都需要进行导入。 使用方法与前一种大同小异，就不多作介绍了。￣ω￣= Moment.JS 与 Webpack 在使用 Moment.js 遇到一些问题，发现最终打包的文件中将 Moment.js 的全部语言包都打包了，导致最终文件徒然增加 100+kB。查了一下，发现可能是 webpack 打包或是 Moment.js 资源引用问题（?），目前该问题还未被妥善处理，需要通过一些 trick 来解决这个问题。 在 webpack 的生产配置文件中的 plugins 字段中添加一个插件，使用内置的方法类 ContextReplacementPlugin 过滤掉 Moment.js 中那些用不到的语言包：12// build/webpack.prod.conf.jsnew webpack.ContextReplacementPlugin(/moment[\\/]locale$/, /^\.\/(zh-cn)$/) 解决方案采自 oleg-nogin@webpack/webpack#3128。问题讨论详见 GitHub Issue: moment/moment#2373、webpack/webpack#3128。 自定义路径别名 可能有些人注意到了，在 vue-cli 生成的模板中在导入组件时使用了这样的语法：1import Index from '@/components/Index' 这个 @ 是什么东西？后来改配置文件的时候发现这个是 webpack 的配置选项之一：路径别名。 我们也可以在基础配置文件中添加自己的路径别名，比如下面这个就把 ~ 设置为路径 src/components 的别名：1234567891011// build/webpack.base.js&#123; resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), '~': resolve('src/components') &#125; &#125;&#125; 然后我们导入组件的时候就可以这样写：12345// import YourComponent from 'YourComponent'// import YourComponent from './YourComponent'// import YourComponent from '../YourComponent'// import YourComponent from '/src/components/YourComponent'import YourComponent from '~/YourComponent' 既解决了路径过长的麻烦，又解决了相对路径的烦恼，方便很多吧！ヾ(ﾟ∀ﾟゞ) CSS 作用域与模块组件内样式 通常，组件中 &lt;style&gt;&lt;/style&gt; 标签里的样式是全局的，在使用第三方 UI 库（如：Element）时，全局样式很可能影响 UI 库的样式。 我们可以通过添加 scoped 属性来使 style 中的样式只作用于当前组件：123456&lt;style lang="less" scoped&gt; @import 'other.less'; .title &#123; font-size: 1.2rem; &#125;&lt;/style&gt; 在有 scoped 属性的 style 标签内导入其他样式，同样会受限于作用域，变为组件内样式。复用程度较高的样式不建议这样使用。 另，在组件内样式中应避免使用元素选择器，原因在于元素选择器与属性选择器组合时，性能会大大降低。 — 两种组合选择器的测试：classes selector，elements selector 导入样式 相对于 style 使用 scoped 属性时的组件内样式，有时候我们也需要添加一些全局样式。当然我们可以用没有 scoped 属性的 style 来写全局样式。 但是相比较，更推荐下面这种写法：123456789/* 单独的全局样式文件 *//* style-global.less */body &#123; font-size: 10px;&#125;.title &#123; font-size: 1.4rem; font-weight: bolder;&#125; 然后在入口文件中导入全局样式：12// src/main.jsimport 'style-global.less' 获取表单控件值 通常我们可以直接使用 v-model 将表单控件与数据进行绑定，但是有时候我们也会需要在用户输入的时候获取当前值（比如：实时验证当前输入控件内容的有效性）。 这时我们可以使用 @input 或 @change 事件绑定我们自己的处理函数，并传入 $event 对象以获取当前控件的输入值：1&lt;input type='text' @change='change($event)'&gt; 12345678change (e) &#123; let curVal = e.target.value if (/^\d+$/.test(curVal)) &#123; this.num = +curVal &#125; else &#123; console.error('%s is not a number!', curVal) &#125;&#125; 当然，如果 UI 框架采用 Element 会更简单，它的事件回调会直接传入当前值。 v-for 的使用 tips v-for 指令很强大，它不仅可以用来遍历数组、对象，甚至可以遍历一个数字或字符串。 基本语法就不讲了，这里讲个小 tips： 索引值 在使用 v-for 根据对象或数组生成 DOM 时，有时候需要知道当前的索引。我们可以这样：123&lt;ul&gt; &lt;li v-for='(item, key) in items' :key='key'&gt; &#123;&#123; key &#125;&#125; - &#123;&#123; item &#125;&#125;&lt;/ul&gt; 但是，在遍历数字的时候需要注意，数字的 value 是从 1 开始，而 key 是从 0 开始：1234&lt;ul&gt; &lt;li v-for='(v, k) in 3' :key='k'&gt; &#123;&#123; k &#125;&#125;-&#123;&#123; v &#125;&#125; &lt;!-- output to be 0-1, 1-2, 2-3 --&gt;&lt;/ul&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 模板的唯一根节点 与 JSX 相同，组件中的模板只能有一个根节点，即下面这种写法是 错误 的：1234&lt;template&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;article&gt;Balabala...&lt;/article&gt;&lt;/template&gt; 我们需要用一个块级元素把他包裹起来：123456&lt;template&gt; &lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;article&gt;Balabala...&lt;/article&gt; &lt;/div&gt;&lt;/template&gt; 原因参考：React-小记：组件开发注意事项#唯一根节点 项目路径配置 由于 vue-cli 配置的项目提供了一个内置的静态服务器，在开发阶段基本不会有什么问题。但是，当我们把代码放到服务器上时，经常会遇到静态资源引用错误，导致界面一片空白的问题。 这是由于 vue-cli 默认配置的 webpack 是以站点根目录引用的文件，然而有时候我们可能需要把项目部署到子目录中。 我们可以通过 config/index.js 来修改文件引用的相对路径：12345build.assetsSubDirectory: 'static'build.assetsPublicPath: '/'dev.assetsSubDirectory: 'static'dev.assetsPublicPath: '/' 我们可以看到导出对象中 build 与 dev 均有 assetsSubDirectory、assetsPublicPath 这两个属性。 其中 assetsSubDirectory 指静态资源文件夹，也就是打包后的 js、css、图片等文件所放置的文件夹，这个默认一般不会有问题。 assetsPublicPath 指静态资源的引用路径，默认配置为 /，即网站根目录，与 assetsSubDirectory 组合起来就是完整的静态资源引用路径 /static。 写到这里解决方法已经很明显了，只要把根目录改为相对目录就好了：12build.assetsSubDirectory: 'static'build.assetsPublicPath: './' 没错！就是一个 . 的问题。ㄟ( ▔, ▔ )ㄏ 更小的 Polyfill 开销 在引入 Polyfill 之后，可以在 .babelrc 文件中开启 useBulitIns 属性。启用该属性后，编译项目时会根据项目中新特性的使用情况将完整的 polyfill 拆分成独立的模块序列。 启用 useBuiltIns 属性：123456789101112// .babelrc&#123; "presets": [ ["env", &#123; "modules": false, "useBuiltIns": true &#125;], "es2015", "stage-2" ] // ...&#125; 安装后引入 babel-polyfill：1234// src/main.jsimport 'babel-polyfill'[1, 2, 3].find((v =&gt; v &gt; 2)) 启用 useBulitIns 后自动拆分 babel-polyfill123import 'core-js/modules/es6.array.find'[1, 2, 3].find((v =&gt; v &gt; 2)) 经测试最大减少了一半左右的 polyfill 体积没深入研究哈，猜测可能加了 core-js 跟一些基础的 polyfill 使用 ESnext class 特性对比 默认时，Vue 单文件组件使用一个对象来描述组件内部的实现：1234567891011121314const App = &#123; // initialized data data () &#123; return &#123; init: false &#125; &#125; // lifecycle hook created () &#123;&#125; mounted () &#123;&#125; // ...&#125;export default App 我们可以通过安装一些依赖来支持最新的 class 写法：1234567891011import Vue from 'vue'import Component from 'vue-class-component'@Componentclass App extends Vue &#123; init = false; created () &#123;&#125; mounted () &#123;&#125;&#125;export default App 不可否认，确实多些了一些代码哈，不过个人还是比较倾向新语法特性的写法的，毕竟标准即是灯塔P.S 这里使用了还处于 Stage 3 的 Field declarations 来声明组件的初始 data 使用 下面来看看需要做哪些改动以支持使用 class 的写法： 首先，最明显的就是我们需要 vue-class-component 这个依赖了。 然后，这个依赖需要 babel 的 transform-decorators-legacy 插件支持。 最后，如果你也想使用 Field declarations 字段声明写法，再添加一个 transform-class-properties 就好了。 安装依赖：123npm i vue-class-component -Dnpm i babel-plugin-transform-decorators-legacy -Dnpm i babel-plugin-transform-class-properties -D 配置 babel12345678910// .babelrc&#123; // ... "plugins": [ "transform-runtime", "transform-decorators-legacy", "transform-class-properties" ] // ...&#125; 注意：transform-decorators-legacy 需放在 transform-class-properties 之前 响应式数据失效数组 由于 Vue.js 响应式数据依赖于对象方法 Object.defineProperty。但很明显，数组这个特殊的“对象”并没有这个方法，自然也无法设置对象属性的 descriptor，从而也就没有 getter() 和 setter() 方法。所以在使用数组索引角标的形式更改元素数据时（arr[index] = newVal），视图往往无法响应式更新。 为解决这个问题，Vue.js 中提供了 $set() 方法：12vm.arr.$set(0, 'newVal')// vm.arr[0] = 'newVal' 对象 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。Ref: 深入响应式原理 - Vue.js 12345678var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 静态类型检测 推荐在开发较复杂的组件时使用 props 静态类型检测，提高组件的健壮性，多数情况下可以在转码阶段提前发现错误。123456// beforeprop: [ 'id', 'multiple', 'callback',] 123456789101112// after props: &#123; id: &#123; type: [ Number, Array ], required: true, &#125;, multiple: &#123; type: Boolean, default: false, &#125;, callback : Function, &#125; 异步组件 使用处于 Stage.3 阶段的动态导入函数 import()，同时借助 webpack 的代码分割功能，在 Vue.js 中我们可以很轻松地实现一个异步组件。 异步路由组件1const AsyncComponent = () =&gt; import('./AsyncComponent') 异步组件工厂1234Vue.component( 'async-webpack-example', () =&gt; import('./my-async-component')) 相比于异步路由组建，异步组件工厂一般适用于组件内进一步小颗粒度的拆分处理，如：大体量组件内初次加载时的非必要组件（组件内嵌套的弹窗组件或 Popover 组件等）。 To be continue…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 常用新特性讲解]]></title>
      <url>%2FJavaScript%2FES6-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[！干货长文预警！ 上周在公司组织了 ES6 新特性的分享会，主要讲了工程化简介、ES6 的新特性与前端常用的几种构建工具的配合使用。ES6 这块主要讲了一些我们平时开发中经常会用到的新特性。在这里整理一下关于 ES6 的部分。一共讲解了 8 个常用的 ES6 新特性，讲解过程也是由浅入深。废话不多说，下面进入正文。 函数默认值特性 &amp; 语法123456// Beforefunction decimal(num, fix) &#123; fix = fix === void(0) ? 2 : fix; return +num.toFixed(fix);&#125; 1234// Afterfunction decimal(num, fix = 2) &#123; return +num.toFixed(fix);&#125; 首先，我们看一下之前我们是怎么写函数默认值的：我们通常会使用三元运算符来判断入参是否有值，然后决定是否使用默认值运行函数（如示例中 fix = fix === void(0) ? 2 : fix） 而在 ES6 中，我们可以直接在函数的显示入参中指定函数默认值（function decimal(num, fix = 2){}），很明显，这种写法更自然易懂，也更加方便，不过有一点需要注意： 设定了默认值的入参，应该放在没有设置默认值的参数之后，也就是我们不应该这样写：function decimal(fix = 2, num){}，虽然通过变通手段也可以正常运行，但不符合规范。 模板字符串特性 &amp; 语法1234567891011121314151617181920212223// Before// Before.1var type = 'simple';'This is a ' + type + ' string join.'// Before.2var type = 'multiline';'This \nis \na \n' + type + '\nstring.'// Before.3var type = 'pretty singleline';'This \is \a \' + type + '\string.'// OR// Before.4'This ' +'is' +'a' +type +'string.' 1234567891011121314151617// Aftervar type = 'singleline';`This is a $&#123;type&#125; string.`var type = 'multiline';`Thisisa$&#123;type&#125;string.`var type = 'pretty singleline';`This \is \a \$&#123;type&#125; \string.` 我们之前在对字符串和变量进行拼接的时候，通常都是反复一段一段使用引号包裹的字符串，再反复使用加号进行拼接（Before.1）。多行字符串的时候我们还要写上蹩脚的 \n 来换行以得到一个多行的字符串（Before.2）。 在字符串过长的时候可能会使用 \ 在编辑器中书写多行字符串来表示单行字符串，用来方便较长的字符串在编辑器中的阅读（Before.3），或者简单粗暴的反复引号加号这样多行拼接（Before.4）。 ES6 中我们可以使用反引号（`，位于 TAB 上方）来输入一段简单明了的多行字符串，还可以在字符串中通过 ${变量名} 的形式方便地插入一个变量，是不是方便多了！ 解构赋值数组解构123var [a, ,b] = [1, 2, 3, 4, 5];console.log(a); // =&gt; 1console.log(b); // =&gt; 3 数组解构，使用变量声明关键字声明一个形参数组（[a, , b]），等号后跟一个待解构目标数组（[1, 2, 3]），解构时可以通过留空的方式跳过数组中间的个别元素，但是在形参数组中必须留有相应空位才可以继续解构之后的元素，如果要跳过的元素处于数组末端，则在形参数组中可以不予留空。 对象解构123var &#123;b, c&#125; = &#123;a: 1, b: 2, c: 3&#125;;console.log(b); // =&gt; 2console.log(c); // =&gt; 3 对象解构与数组解构大体相同，不过需要注意一点 形参对象（{b, c}）的属性或方法名必须与待解构的目标对象中的属性或方法名完全相同才能解构到对应的属性或方法 对象匹配解构12345var example = function() &#123; return &#123;a: 1, b: 2, c: 3&#125;;&#125;var &#123;a: d, b: e, c: f&#125; = example();console.log(d, e, f); // =&gt; 1, 2, 3 对象匹配解构是对象解构的一种延伸用法，我们可以在形参对象中使用:来更改解构后的变量名。 函数入参解构1234function example(&#123;param: value&#125;) &#123; return value;&#125;console.log(example(&#123;param: 5&#125;)); // =&gt; 5 函数的入参解构也是对象解构的一种延伸用法，我们可以通过改写入参对象目标值为变量名的方式，在函数内部直接获取到入参对象中某个属性或方法的值。 函数入参默认值解构12345function example(&#123;x, y, z = 0&#125;) &#123; return x + y + z;&#125;console.log(example(&#123;x: 1, y: 2&#125;)); // =&gt; 3console.log(example(&#123;x: 1, y: 2, z: 3&#125;)); // =&gt; 6 这是入参解构的另一种用法，我们可以在入参对象的形参属性或方法中使用等号的方式给入参对象的某些属性或方法设定默认值。 Let &amp; ConstLet 无变量提升 123// Beforeconsole.log(num); // =&gt; undefinedvar num = 1; 123// Afterconsole.log(num); // =&gt; ReferenceErrorlet num = 1; 使用 var 声明的变量会自动提升到当前作用域的顶部，如果声明位置与作用域顶部之间有另一个同名变量，很容易引起难以预知的错误。使用 let 声明的变量则不会进行变成提升，规避了这个隐患。 注意：var 声明的变量提升后虽然在声明语句之前输出为 undefined，但这并不代表 num 变量还没有被声明，此时 num 变量已经完成声明并分配了相应内存，只不过该变量目前的值为 undefined，并不是我们声明语句中赋的初始值 1。 有块级作用域 1234567// Before&#123; var num = 1; console.log(num); // =&gt; 1&#125;console.log(num); // =&gt; 1 1234567// After&#123; let num = 1; console.log(num); // =&gt; 1&#125;console.log(num); // =&gt; ReferenceError let 声明的变量只能在当前块级作用域中使用，最常见的应用大概就是 for(let i = 0, i &lt; 10; i++) {}，相信许多小伙伴在面试题中见过，哈哈。 禁止重复声明 12345// Beforevar dev = true;var dev = false;console.log(dev); // =&gt; false 123// Afterlet dev = true;let dev = false; // =&gt; SyntaxError var 声明的变量可以重复声明，而且不会有任何警告或者提示，就这样悄悄的覆盖了一个值，隐患如变量提升一样让人担忧。(￣┰￣*) 而 let 声明的变量如果进行重复声明，则会直接抛出一个语法错误（是的，就是直接明确地告诉你：你犯了一个相当低级的语法错误哦） Const 无变量提升 有块级作用域 禁止重复声明 前 3 点跟 let 一个套路，就不多说了 禁止重复赋值 12const DEV = true;DEV = false; // =&gt; TypeError 基于静态常量的定义我们可以很明显知道，const 声明的常量一经声明便不能再更改其值，无需多说。 必须附初始值 1const DEV; // =&gt; SyntaxError 也是基于定义，const 声明的常量既然一经声明便不能再更改其值，那声明的时候没有附初始值显然是不合理的，一个没有任何值的常量是没有意义的，浪费内存。 新增库函数 ES6 新增了许多（相当多）的库函数，这里只介绍一些比较常用的。 题外话：多了解一下内建函数与方法有时候可以很方便高效地解决问题。有时候绞尽脑汁写好的一个算法，没准已经有内建函数实现了！而且内建函数经过四海八荒众神的考验，性能一定不错，哈哈。 Number123Number.EPSILONNumber.isInteger(Infinity); // =&gt; falseNumber.isNaN('NaN'); // =&gt; false 首先是 ᶓ 这个常量属性，表示小数的极小值，主要用来判断浮点数计算是否精确，如果计算误差小于该阈值，则可以认为计算结果是正确的。 然后是 isInteger() 这个方法用来判断一个数是否为整数，返回布尔值。 最后是 isNaN() 用来判断入参是否为 NaN。是的，我们再也不用通过 NaN 不等于 NaN 才能确定一个 NaN 就是 NaN 这种反人类的逻辑来判断一个 NaN 值了！123if(NaN !== NaN) &#123; console.log("Yes! This is actually the NaN!");&#125; 另外还有两个小改动：两个全局函数 parseInt() 与 parseFloat() 被移植到 Number 中，入参反参保持不变。这样所有数字处理相关的都在 Number 对象上嘞！规范多了。 String1234'abcde'.includes('cd'); // =&gt; true'abc'.repeat(3); // =&gt; 'abcabcabc''abc'.startsWith('a'); // =&gt; true'abc'.endsWith('c'); // =&gt; true inclueds() 方法用来判断一个字符串中是否存在指定字符串 repeat() 方法用来重复一个字符串生成一个新的字符串 startsWith() 方法用来判断一个字符串是否以指定字符串开头，可以传入一个整数作为第二个参数，用来设置查找的起点，默认为 0，即从字符串第一位开始查找 endsWith() 与 startsWith() 方法相反 Array12345678910111213141516Array.from(document.querySelectorAll('*')); // =&gt; returns a real array.[0, 0, 0].fill(7, 1); // =&gt; [0, 7, 7][1, 2, 3].findIndex(function(x) &#123; return x === 2;&#125;); // =&gt; 1['a', 'b', 'c'].entries(); // =&gt; Iterator [0: 'a'], [1: 'b'], [2: 'c']['a', 'b', 'c'].keys(); // =&gt; Iterator 0, 1, 2['a', 'b', 'c'].values(); // =&gt; Iterator 'a', 'b', 'c'// Beforenew Array(); // =&gt; []new Array(4); // =&gt; [,,,]new Array(4, 5, 6); // =&gt; [4, 5, 6]// AfterArray.of(); // =&gt; []Array.of(4); // =&gt; [4]Array.of(4, 5, 6); // =&gt; [4, 5, 6] 首先是 from() 方法，该方法可以将一个类数组对象转换成一个真正的数组。还记得我们之前常写的 Array.prototype.slice.call(arguments) 吗？现在可以跟他说拜拜了~ 之后的 fill() 方法，用来填充一个数组，第一个参数为将要被填充到数组中的值，可选第二个参数为填充起始索引（默认为 0），可选第三参数为填充终止索引（默认填充到数组末端）。 findIndex() 用来查找指定元素的索引值，入参为函数，函数形参跟 map() 方法一致，不多说。最终输出符合该条件的元素的索引值。 entries()、keys()、values() 三个方法各自返回对应键值对、键、值的遍历器，可供循环结构使用。 最后一个新增的 of() 方法主要是为了弥补 Array 当做构造函数使用时产生的怪异结果。 Object12345678910let target = &#123; a: 1, b: 3&#125;;let source = &#123; b: 2, c: 3&#125;;Object.assign(target, source); // =&gt; &#123; a: 1, b: 2, c: 3&#125; assign() 方法用于合并两个对象，不过需要注意的是这种合并是浅拷贝。可能看到这个方法我们还比较陌生，不过了解过 jQuery 源码的应该知道 $.extend() 这个方法，例如在下面这个粗糙的 $.ajax() 模型中的应用：12345678$.ajax = function(opts) &#123; var defaultOpts = &#123; method: 'GET', async: true, //... &#125;; opts = $.extend(defaultOpts, opts);&#125; 从这我们可以看到 TC39 也是在慢慢吸收百家所长，努力让 JavaScript 变得更好，更方便开发者的使用。 Object 新增的特性当然不止这一个 assign() 方法，一共增加了十多个新特性，特别是对属性或方法名字面量定义的增强方面，很值得一看，感兴趣的自行查找资料进行了解哈，印象会更深刻！ Math Math 对象上同样增加了许多新特性，大部分都是数学计算方法，这里只介绍两个常用的123456Math.sign(5); // =&gt; +1Math.sign(0); // =&gt; 0Math.sign(-5); // =&gt; -1Math.trunc(4.1); // =&gt; 4Math.trunc(-4.1); // =&gt; -4 sign() 方法用来判断一个函数的正负，使用与对应返回值如上。 trunc() 用来取数值的整数部分，我们之前可能经常使用 floor() 方法进行取整操作，不过这个方法有一个问题就是：它本身是向下取整，当被取整值为正数的时候计算结果完全 OK，但是当被取整值为负数的时候：1Math.floor(-4.1); // =&gt; -5 插播一个小 Tip：使用位操作符也可以很方便的进行取整操作，例如：~~3.14 or 3.14 | 0，也许这更加方便 : ) 箭头函数 箭头函数无疑是 ES6 中一个相当重要的新特性。 特性 共享父级 this 对象 共享父级 arguments 不能当做构造函数 语法最简表达式12345678var arr = [1, 2, 3, 4, 5, 6];// Beforearr.filter(function(v) &#123; return v &gt; 3;&#125;);// Afterarr.filter(v =&gt; v &gt; 3); // =&gt; [4, 5, 6] 前后对比很容易理解，可以明显看出箭头函数极大地减少了代码量。 完整语法12345var arr = [1, 2, 3, 4, 5, 6];arr.map((v, k, thisArr) =&gt; &#123; return thisArr.reverse()[k] * v;&#125;) // =&gt; [6, 10, 12, 12, 10, 6] 一个简单的首尾相乘的算法，对比最简表达式我们可以发现，函数的前边都省略了 function 关键字，但是多个入参时需用括号包裹入参，单个入参是时可省略括号，入参写法保持一致。后面使用胖箭头 =&gt; 连接函数名与函数体，函数体的写法保持不变。 函数上下文 this1234567891011121314151617181920212223// Beforevar obj = &#123; arr: [1, 2, 3, 4, 5, 6], getMaxPow2: function() &#123; var that = this, getMax = function() &#123; return Math.max.apply(&#123;&#125;, that.arr); &#125;; return Math.pow(getMax(), 2); &#125;&#125;// Aftervar obj = &#123; arr: [1, 2, 3, 4, 5, 6], getMaxPow2: function() &#123; var getMax = () =&gt; &#123; return Math.max.apply(&#123;&#125;, this.arr); &#125; return Math.pow(getMax(), 2); &#125;&#125; 注意看中第 5 行 var that = this 这里声明的一个临时变量 that。在对象或者原型链中，我们以前经常会写这样一个临时变量，或 that 或 _this，诸如此类，以达到在一个函数内部访问到父级或者祖先级 this 对象的目的。 如今在箭头函数中，函数体内部没有自己的 this，默认在其内部调用 this 的时候，会自动查找其父级上下文的 this 对象（如果父级同样是箭头函数，则会按照作用域链继续向上查找），这无疑方便了许多，我们无需在多余地声明一个临时变量来做这件事了。 注意： 某些情况下我们可能需要函数有自己的 this，例如 DOM 事件绑定时事件回调函数中，我们往往需要使用 this 来操作当前的 DOM，这时候就需要使用传统匿名函数而非箭头函数。 在严格模式下，如果箭头函数的上层函数均为箭头函数，那么 this 对象将不可用。 另，由于箭头函数没有自己的 this 对象，所以箭头函数不能当做构造函数。 父级函数 arguments 我们知道在函数体中有 arguments 这样一个伪数组对象，该对象中包含该函数所有的入参（显示入参 + 隐式入参），当函数体中有另外一个函数，并且该函数为箭头函数时，该箭头函数的函数体中可以直接访问父级函数的 arguments 对象。1234567891011function getSum() &#123; var example = () =&gt; &#123; return Array .prototype .reduce .call(arguments, (pre, cur) =&gt; pre + cur); &#125; return example();&#125;getSum(1, 2, 3); // =&gt; 6 由于箭头函数本身没有 arguments 对象，所以如果他的上层函数都是箭头函数的话，那么 arguments 对象将不可用。 最后再巩固一下箭头函数的语法： 当箭头函数入参只有一个时可以省略入参括号； 当入参多余一个或没有入参时必须写括号； 当函数体只有一个 return 语句时可以省略函数体的花括号与 return 关键字。 类 &amp; 继承 类也是 ES6 一个不可忽视的新特性，虽然只是句法上的语法糖，但是相对于 ES5，学习 ES6 的类之后对原型链会有更加清晰的认识。 特性 本质为对原型链的二次包装 类没有提升 不能使用字面量定义属性 动态继承类的构造方法中 super 优先 this 类的定义12345678910111213141516171819202122232425262728293031/* 类不会被提升 */let puppy = new Animal('puppy'); // =&gt; ReferenceErrorclass Animal &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(`The $&#123;this.name&#125; is sleeping...`); &#125; static type() &#123; console.log('This is an Animal class.'); &#125;&#125;let puppy = new Animal('puppy');puppy.sleep(); // =&gt; The puppy is sleeping.../* 实例化后无法访问静态方法 */puppy.type(); // =&gt; TypeErrorAnimal.type(); // =&gt; This is an Animal class./* 实例化前无法访问动态方法 */Animal.sleep(); // =&gt; TypeError/* 类不能重复定义 */class Animal() &#123;&#125; // =&gt; SyntaxError 以上我们使用 class 关键字声明了一个名为 Animal 的类。 虽然类的定义中并未要求类名的大小写，但鉴于代码规范，推荐类名的首字母大写。 两点注意事项： 在类的定义中有一个特殊方法 constructor()，该方法名固定，表示该类的构造函数（方法），在类的实例化过程中会被调用（new Animal(&#39;puppy&#39;)）； 类中无法像对象一样使用 prop: value 或者 prop = value 的形式定义一个类的属性，我们只能在类的构造方法或其他方法中使用 this.prop = value 的形式为类添加属性。 最后对比一下我们之前是怎样写类的：12345678910111213function Animal(name) &#123; this.name = name;&#125;Animal.prototype = &#123; sleep: function()&#123; console.log('The ' + this.name + 'is sleeping...'); &#125;&#125;;Animal.type = function() &#123; console.log('This is an Animal class.');&#125; class 关键字真真让这一切变得清晰易懂了~ 类的继承12345678910111213141516171819202122class Programmer extends Animal &#123; constructor(name) &#123; /* 在 super 方法之前 this 不可用 */ console.log(this); // =&gt; ReferenceError super(name); console.log(this); // Right! &#125; program() &#123; console.log("I'm coding..."); &#125; sleep() &#123; console.log('Save all files.'); console.log('Get into bed.'); super.sleep(); &#125;&#125;let coder = new Programmer('coder');coder.program(); // =&gt; I'm coding...coder.sleep(); // =&gt; Save all files. =&gt; Get into bed. =&gt; The coder is sleeping. 这里我们使用 class 定义了一个类 Programmer，使用 extends 关键字让该类继承于另一个类 Animal。 如果子类有构造方法，那么在子类构造方法中使用 this 对象之前必须使用 super() 方法运行父类的构造方法以对父类进行初始化。 在子类方法中我们也可以使用 super 对象来调用父类上的方法。如示例代码中子类的 sleep() 方法：在这里我们重写了父类中的 sleep() 方法，添加了两条语句，并在方法末尾使用 super 对象调用了父类上的 sleep() 方法。 俗话讲：没有对比就没有伤害 (*゜ー゜*)，我们最后来看一下以前我们是怎么来写继承的：1234567891011121314151617181920function Programmer(name) &#123; Animal.call(this, name);&#125;Programmer.prototype = Object.create(Animal.prototype, &#123; program: &#123; value: function() &#123; console.log("I'm coding..."); &#125; &#125;, sleep: &#123; value: function() &#123; console.log('Save all files.'); console.log('Get into bed.'); Animal.prototype.sleep.apply(this, arguments); &#125; &#125;&#125;);Programmer.prototype.constructor = Programmer; 如果前文类的定义中的前后对比不足为奇，那么这个。。。 给你一个眼神，自己去体会 (⊙ˍ⊙)，一脸懵逼.jpg 模块 啊哈，终于写到最后一部分了。 模块系统是一切模块化的前提，在未推出 ES6 Module 标准之前，相信大伙儿已经被满世界飞的 AMD、CMD、UMD、CommonJS 等等百花齐放的模块化标准搞的晕头转向了吧。但是，现在 TC39 在 ECMAScript2015(ES6) 版本里终于推出了正式的模块化规范，前端模块系统的大一统时代已经到来了！ OMG，这段话写的好燃 orz 废话有点多。。。 下面咱们来了解一个这个模块系统的基本规范。 为方便描述，下文中导出对象指一切可导出的内容（变量、函数、对象、类等），勿与对象（Object）混淆。导入对象同理。 特性 封闭的代码块每个模块都有自己完全独立的代码块，跟作用域类似，但是更加封闭。 无限制导出导出一个模块理论上可以导出无数个变量、函数、对象属性、对象方法，甚至一个完整的类。但是我们应该时刻牢记单一职责这一程序设计的基本原则，不要试图去开发一个臃肿的巨大的面面俱到的模块，合理控制代码的颗粒度也是开发可维护系统必不可少的一部分。 严格模式下运行模块默认情况下在严格模式下运行（&#39;use strict;&#39;），这时候要注意一些取巧甚至有风险的写法应该避免，这也是保证代码健壮性的前提。 模块的定义与导出内联导出12345678910111213export const DEV = true;export function example() &#123; //...&#125;export class expClass &#123; //...&#125;export let obj = &#123; DEV, example, expClass, //...&#125; 使用 export 关键字，后面紧跟声明关键字（let、function 等）声明一个导出对象，这种声明并同时导出的导出方式称作内联导出。 未被导出的内容（变量、函数、类等）由于独立代码块的原因，将仅供模块内部使用（可类比成一种闭包）。 对象导出1234567891011121314151617// module example.jsconst DEV = true;function example() &#123; //...&#125;class expClass &#123; //...&#125;let obj = &#123; DEV, example, expClass, //...&#125;// module example.jsexport &#123;DEV, example, expClass, obj&#125;;export &#123;DEV, example as exp, expClass, obj&#125;; 相对于内联导出，上边的这种方式为对象导出。我们可以像写普通 JS 文件一样写主要的功能逻辑，最后通过 export 集中导出。 在导出时我们可以使用 as 关键字改变导出对象的名称。 默认导出12345export default &#123;DEV, example as exp, expClass, obj&#125;;// ORexport default obj;// ORexport default const DEV = true; 我们可以在 export 关键字后接 default 来设置模块的默认导出对象，需要注意的是：一个模块只能有一个默认导出。 先不多说，后面讲导入的时候再细讲相互之间的关联。 模块的导入与使用自定义模块 前文我们定义了一个名为 example 的模块，写在文件 example.js中，下面我们来导入并使用这个模块。123import example from './example.js';// OR import default as example from './example.js'; 使用 import 关键字导入一个模块，上边这两种写法是等效的。默认导入对象既是模块默认导出对象，即对应模块定义中的 export default 所导出的内容。 此外我们还可以这样导入一个模块：123import &#123;DEV, example&#125; from './example.js';import * as exp from './example.js';import &#123;default as expMod, * as expAll, DEV, example as exp&#125; from './example.js'; 这种导入方式对应模块定义中的 export {DEV, example, expClass, obj} 或 export const DEV = true。下面我们逐行分析： 第一行，我们使用对象导入的方式导入一个模块内容，可能有些人已经发现，这跟解构赋值很相似，但也有不同，下面会讲到。需要注意的是形参对象（{DEV, example}）与模块定义中导出的名称必须保持一致。 第二行，导入时可以使用通配符 * 配合 as 关键字一次性导出模块中所有内容，最终导入的内容放在 exp 对象中。 第三行，在使用对象导入来导入一个模块的指定内容时，也可以使用 as 关键字更改最终导入对象的名称，这里表现出与解构赋值的一个不同之处，忘记解构赋值的小伙伴可以翻翻前文对比一下哈~ 最后，在导入一个模块后我们就可以直接使用模块的函数、变量、类等了，完整的代码示例：1234567import &#123;DEV, example, expClass as EC&#125; from './example.js';if(DEV) &#123; let exp = new EC(); // anything you want... example();&#125; 好嘞！到这里，ES6 常用的 8 个新特性就讲完了，恭喜你耐心地看完了。当然，还有许多地方没有讲到，有时间的话会考虑继续写一些。 好嘞，就这样吧，希望对你有所帮助，拜拜~&lt;(*￣▽￣*)/。 文中部分专业名词由于未找到合适译文，最后自行翻译，如有不妥，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 JavaScript 中函数为什么被称作一等公民？]]></title>
      <url>%2FJavaScript%2F%E5%9C%A8-JavaScript-%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E7%A7%B0%E4%BD%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[如果读过MDN的话，应该会注意到MDN上对JavaScript的定义部分是这样写的： JavaScript (JS) is a lightweight interpreted or JIT-compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as node.js and Apache CouchDB. JavaScript is a prototype-based, multi-paradigm, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Read more about JavaScript. 开篇定义中便提到了函数优先（First-class Function），也即通常所说的JavaScript中的一等公民Funciton。那问题来了：这个一等公民为什么会被称作一等公民呢？哪些特征让函数在JavaScript中成为了一等公民？ 其他语言中的函数在许多其他语言中（例如我们熟知的C、C#、Java等）中，只能用语言规定的关键字去声明一个函数，也必须使用声明的函数名调用，如果需要将函数本身进行传递、赋值等操作就只能借用函数指针（即引用地址）来操作，本质上还是操作原来的那个函数，也就是必须声明了一个函数，才能进行引用等操作。 JavaScript 中的函数在JavaScript中，函数作为一等公民，他不仅拥有其他语言中函数的一切声明和调用方式，更可以像普通变量一样赋值、传递、反参。此外，在JavaScript中函数还可以通过new关键字拥有构造函数的功能。 下面这些使用方法在JavaScript中很常见，但是，现在我们在使用时应该知道，正是因为在JavaScript中函数是一等公民，所以才有这些用法： 函数表达式1function [name]([param] [, param] [..., param]) &#123; statements &#125; 两种常见使用方式： 自运行匿名函数123(function() &#123; // everything&#125;()) 匿名函数赋值1var func = function() &#123;&#125; 函数嵌套普通嵌套12345678910function a() &#123; console.log(1); // 在函数 a 中声明一个函数 b function b() &#123; console.log(2); &#125; b();&#125;a(); // =&gt; 1 =&gt; 2 匿名嵌套匿名嵌套主要用于防止全局变量污染1234567;(function() &#123; function a() &#123; console.log(1); &#125; a(); // =&gt; 1&#125;())a(); // =&gt; ReferenceError: a is not defined 高阶函数如果函数作为参数或返回值使用时，就称为高阶函数。 函数传递将一个函数作为另一函数的参数进行传递1234567891011// 声明一个函数 afunction a() &#123; console.log(1);&#125;// 声明一个带参函数 bfunction b(callback) &#123; console.log(2); // 执行作为参数传递进来的函数 callback &amp;&amp; callback();&#125;b(a); // =&gt; 2 =&gt; 1 反参函数将一个函数作为另一函数的反参输出12345678910function a() &#123; var v = 0; function b() &#123; console.log(v + 1); &#125; return b;&#125;a()(); // =&gt; 1 构造函数12345678910111213function a() &#123; console.log(1);&#125;a.prototype.b = 2;a.prototype.c = function() &#123; console.log(this.b); console.log(3); this.d = 4; console.log(this.d); var e = 5; console.log(5);&#125;new a().c(); // =&gt; 1 =&gt; 2 =&gt; 3 =&gt; 4 =&gt; 5 最后附上MDN上对于First-class Function的解释： A programming language is said to have First-class functions when functions in that language are treated like any other variable. For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-小记：组件开发注意事项]]></title>
      <url>%2FJavaScript%2FReact-%E5%B0%8F%E8%AE%B0%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[组件（Component）是React中非常重要的概念，React组件基于jsx语法开发，也就是把HTML写在JS中，刚开始接触的时候还是蛮抵触的，什么都搅在一起感觉挺乱的。不过真正开发起来会发现，只要颗粒度划分合理，一个完整的组件，所有内容都在一个文件中维护是多么方便！ 当然你也可以使用工厂方法进行开发，不过个人感觉很不直观且繁琐 基本使用方法直接引用12345678import React from 'react';import ReactDOM from 'react-dom';import Button from './component/button.jsx';ReactDOM.render( &lt;Button name='Click Me' /&gt;, document.getElementById('index')); 首先组件import时首字母必须大写，然后通过&lt;组件名 [参数1=值1, 参数2=值2...]/&gt;引用，参数会传入组件的构造函数中不能在组件引用上绑定事件，即&lt;Button onClick={ clickHandler } /&gt;，因为组件引用中除了组件名，其他部分都应该是组件入参。不过可以通过参数的形式将回调函数传到组件内部，然后进行绑定。 组件嵌套12345678910import &#123; Component &#125; from 'react';import Button from './component/botton.jsx';class DefaultBtn extends Component &#123; render() &#123; return &lt;Button name='Default' /&gt;; &#125;&#125;export default DefaultBtn; 这里定义了一个新组件DefaultBtn，该组件有引用了一个Button组件，并传入了参数name为Default 基本写法无状态的静态组件是最简单的，这里把常用的写法都写下了123456789101112131415161718192021222324252627282930313233import &#123; Component &#125; from 'react';class Button extends Component &#123; constructor(props) &#123; super(props); console.log(this.props.name); &#125; buttonClick(e) &#123; e.preventDefault(); console.log('button clicked!'); &#125; render() &#123; let buttonStyle = &#123; backgroundColor: '#03A9F4', padding: '3px 20px' &#125; return ( &lt;button className = 'buttonClass' onClick = &#123; this.buttonClick.bind(this) &#125; style = &#123; buttonStyle &#125; &gt; &#123; this.props.name &#125; &lt;/button&gt; ); &#125;&#125;export default Button; 不痛不痒的提示 组件名首字母必须大写 样式类的属性名是className不是class 事件绑定通过on+eventType小驼峰写法 JSX描述DOM时，所有属性都采用小驼峰写法这点很棒，一直对DOM中各种方法名时而大写时而小写感到不解，这里全规定为小驼峰写法，顿时顺眼多了 元素内嵌样式使用对象来描述，样式属性名同样使用小驼峰写法，如backgroundColor JSX中可以使用{}来写JS语句 几点踩坑点： React 引入名在组件中如果引入React，则首字母须大写，也就是说引入React时不可以写成1import react form 'react'; 在实际项目中，只要入口文件下所依赖的文件有一个进行了正确的import就可以嘞，毕竟webpack最后会把依赖去重。 原因：在编译过程中，组件的许多部分都会转成对React中各个方法的引用，比如：render()的return被编译后，实质上返回的是React.createElement()，上文return语句编译后：123456789return React.createElement( 'botton', &#123; className: 'buttonClass', onClick: this.buttonClick.bind(this) style: buttonStyle, &#125;, this.props.name) 唯一根节点如果上文你想返回两个button，你可能会这样写：1234render() &#123; return (&lt;button&gt;Button1&lt;/button&gt; &lt;button&gt;Button2&lt;/button&gt;);&#125; BUT，这是不行的，在render()中返回的React元素只能有一个根节点（原因看上文中的React.createElement()），也就是说，你只能这样写：123456render () &#123; return (&lt;div&gt; &lt;button&gt;Button1&lt;/button&gt; &lt;button&gt;Button2&lt;/button&gt; &lt;/div&gt;);&#125; 莫名其妙多了一层，我也很绝望啊 (。﹏。*) 事件回调中的 this在JSX中给DOM绑定事件时，回调函数默认情况下无法访问当前组件，即回调函数中this不可用，一般情况下我们可以通过bind()来改变函数的上下文来使其可用：1onClick = &#123; this.buttonClick.bind(this) &#125; 或者在组件的构造函数中：12345678class Button extends React.Component &#123; constructor(props) &#123; super(props); this.buttonClick = this.buttonClick.bind(this); &#125; //buttonClick(), render()...&#125; 或者将事件回调放在一个上下文中：123&lt;button onClick = &#123; () =&gt; this.buttonClick() &#125; &gt; ButtonName&lt;/button&gt; 比较倾向使用第一种方法，毕竟有时候访问this并不是必须的，随用随绑~ 事件回调处理在React事件回调函数中，可以显式传入一个合成事件（SyntheticEvent）的实例，他有如下属性与方法：1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type 对于大多数常用事件的处理来说并不会感到有什么不同。不过在开发时还是需要注意，这个实例中封装了一些React特有的事件类型，可能与传统事件的属性与方法并不一一对应。 事件回调需要注意： 显式传入 Event回调函数中须显式传入event参数： 123456789buttonClick() &#123; // It doesn't work. event.preventDefault(); console.log(event.type); // =&gt; 'react-click'&#125;buttonClick(event) &#123; event.preventDefault(); console.log(event.type); // =&gt; 'click'&#125; 默认事件处理从 v0.14 开始，在事件回调函数中return false;将不再阻止事件的传递与元素的默认事件，需要在事件处理函数中手动写上e.stopPropagation()或e.preventDefault()。 合成事件无法异步为了提高性能，合成事件（SyntheticEvent）是全局的，也就是说实质上只有一个合成事件，默认情况下当回调执行完毕后，所有属性都会被重置以便复用，回调函数中传入的event参数可以看做是他的一个状态，当回调执行完后就会被立刻重置，所以在异步函数中只能访问到被重置后的默认合成事件，而无法访问事件发生时的合成事件。1234buttonClick(event) &#123; console.log(event.type); // =&gt; 'click' setTimeout(() =&gt; console.log(event.type), 0); // =&gt; null&#125; 不过出于特殊考虑，React提供了event.persist()方法使当前事件不被重置，效果类似于深度拷贝了一个对象。关于事件的其他细节可以参考SyntheticEvent - React 先写这些吧，想起来再补充]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-小记：开发环境准备]]></title>
      <url>%2FJavaScript%2FReact-%E5%B0%8F%E8%AE%B0%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%2F</url>
      <content type="text"><![CDATA[写下这个标题之后我愣了几分钟，突然发现无从下笔。随后想了想，就当是学习React过程中的随笔吧，写点简单的开发过程顺便记一些刚接触时踩到的坑。 准备工作React Developer Tools首先需要准备的就是React提供的Chrome拓展工具了，这个扩展在检测到开发状态的React程序时会在控制台添加一个React工具栏。在这里可以很方便的查看到组件间结构、属性、状态跟事件，可以很方便地进行调试：下载地址：React Developer Tools Webpack由于React无法直接在浏览器环境中运行，需要使用Webpack进行通过Babel编译打包。 当然你也可以直接引入react.js跟react-dom.js直接在浏览器中跑，不过很卡就是了。。。 下面是webpack的低配：123456789101112131415161718192021var path = require('path'), root = path.resolve(__dirname), src = path.resolve(root, 'js'), dist = path.resolve(root, '../js');module.exports = &#123; entry: path.resolve(src, 'index.jsx'), output: &#123; path: dist, filename: 'index.js' &#125;, devtool: 'cheap-module-eval-source-map', module: &#123; loaders: [ &#123; test: /\.jsx$/, loader: 'babel' &#125; ] &#125;&#125; 简单说明： entry：入口文件，webpack说白了就是从入口文件一层层地查找代码中使用了require(xxx)或import x from x语句，把所有依赖的文件全都写到一个文件里。对，就这么简单！ output：指定最终打包好的文件输出到哪里，没什么可说的 devtool：指定开发时生成sourceMap的格式，绝大多数直接用cheap-module-eval-source-map就OK，想深入了解的点这里 module.loaders：一系列的加载器，test用来匹配require(xxx)中的xxx来确定是否用这个加载器处理所识别到的文件。loader用来指定加载器，这里指定的babel需要安装依赖npm i -D babel-loader BabelBabel的使用参考：从零开始：现在开始用ES6写代码这里的额外配置就是加一个react的转码包： 安装预置转码包npm i -D babel-preset-react 修改配置文件.babelrc123&#123; "presets": ["react", "es2015"]&#125; 项目入口访问入口 index.html首先我们要准备一个近乎空白的HTML文档：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;React Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个HTML文件head按需设置，或引入样式表，或设置meta，随你喜欢，body节点中ID为root的节点则是我们react所有DOM渲染的的目标节点，一般情况下不要直接渲染到body节点中，虽然可以正常加载，但是控制台会弹出警告，这是因为许多工具或插件（譬如弹窗）也会渲染DOM到body节点中，这会影响React的正常运行 下面就是一个脚本引用，引用webpack配置中output所指的输出文件。 逻辑入口 index.js这个入口其实就是webpack配置中的entry所指向的文件，也就是上文访问入口中引用的脚本文件，webpack将从这个文件开始查找依赖123456// index.jsimport React from 'react';import ReactDOM from 'react-dom';import Index from './component/index.jsx';ReactDOM.render(&lt;Index /&gt;, document.getElementById('index')); 引入三个依赖，其中前两个为React基础依赖，必须引入，最后一个为我们自己写的一个组件。webpack编译时将从这三条语句出发，按顺序查找依赖（按树查找，即：如果依赖中还有其他依赖，则一直查找下去，直到依赖树的末端为止），最后读取查找到的全部文件内容后，按照依赖顺序写入到当前文件中，最终输出到output中指定的位置 ReactDOM.render()第一个参数为将要渲染的React元素，这里的&lt;Index /&gt;则是直接把第三行引入的组件直接放到这里进行渲染，第二个参数是指把这个组件渲染到页面的哪个DOM节点中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端构建系统Gulp的使用与常用插件推荐]]></title>
      <url>%2FJavaScript%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9FGulp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[随着Web前端发展，前端项目变得越来越复杂，随之而来的是各种方便的工具：打包工具、转码工具、JS 与CSS的合并压缩工具等等。这些工具极大的提高了我们前端的代码质量，但问题也随之而来： 这么多工具到底该怎么使用，难道一个个在各个工具中来回切换复制粘贴？或是在CLI里一条条地敲命里吗？敲完代码还要敲一堆的构建命令，说不准顺序搞错了还要功亏一篑重来一遍？纳尼？！！ 于是构建系统应运而生，Gulp, Grunt, Browserify, etc. 使用构建系统的好处显而易见，就是一次配置，自动构建，省心省力妙不可言（怎么像广告词 orz） 此外因为配置文件的高度统一，这个配置文件几乎可以多个项目之间随便复制粘贴修修改改就可以重复使用！ 不过可用的构建系统有很多，为避免引起圣战这里不做讨论_(:зゝ∠)_，我就用Gulp~ 好嘞，废话说了这么多，下面进入正文： Node 与 Gulp 的安装参考：从零开始：现在开始用ES6写代码，使用Babel对ES6进行转码也就不在这里啰嗦嘞~ 为静态文件添加 MD5 指纹使用Gulp自动对HTML中引用的静态文件添加MD5指纹戳，有效解决旧文件缓存，新文件无法更新的问题。 这部分有两种解决方案 将MD5指纹写入文件名 效果：&lt;script src=&#39;BearD01001-366dc531e1.min.js&#39;&gt;&lt;/script&gt; 优点：几乎可完美规避更新时短时间内客户端请求结果不一致的问题 缺点：每次修改文件都会产生一个新文件，易造成文件冗余 建议：推荐流量大、或没有绝对高峰期只有相对高峰期的大型Web系统使用 插件：gulp-rev 写至文件引用URI的query中 效果：&lt;script src=&#39;BearD01001.min.js?rev=366dc531e1&#39;&gt;&lt;/script&gt; 优点：每次更新不会产生新文件，有效避免文件冗余 缺点：更新时短时间内，客户端请求到的静态文件可能不一致，造成非预期结果 建议：推荐流量小、或可规避高峰期更新的Web系统使用 插件：gulp-rev-append 两种解决方案优缺点已经说明，两个插件的使用方法也很简单，直接pipe到插件中就 OK ，这里不多废话嘞~ 123456789var gulp = require('gulp');var rev = require('gulp-rev');// var revAppend = require('gulp-rev-append');gulp.task('html', () =&gt; &#123; gulp.src('*.html') .pipe(rev()) // .pipe(revAppend()) .pipe(gulp.dest('./'));&#125;); 生成 Source Map说到Source Map可能会有些小伙伴儿有些陌生，说白了这货就是在转码编译之前的文件与之后的文件生成一个字符对照表（深入了解参考 &gt;&gt; JavaScript Source Map 详解）。 这样在浏览器开发者工具中，只要开启sourcemaps，调试过程中就可以在开发者工具中直接看到编译前的源文件，而不是编译后的文件。 如果出现问题也是直接报出问题出在源文件的哪行哪列，Debug起来相当方便！ 插件 gulp-sourcemaps 简介额(⊙_⊙)…上边好像说的差不多了 使用一般使用方法（不推荐） 12345678gulp.task('javascript', () =&gt; &#123; gulp.src('src/**/*.js') .pipe(sourcemaps.init()) .pipe(plugin1()) .pipe(plugin2()) .pipe(sourcemaps.write()) .pipe(gulp.dest('dist'));&#125;); 不推荐的原因是gulp-sourcemaps插件默认会将文件对照表信息全部写入转码编译后的文件末端。 一般这个对照表的信息量还是很大的，这对生产线上浏览器请求加载文件无疑是无用额外的开销，手动去除也是一件很低效费时的工作。 指定输出路径（推荐） 12345678gulp.task('javascript', () =&gt; &#123; gulp.src('src/**/*.js') .pipe(sourcemaps.init()) .pipe(plugin1()) .pipe(plugin2()) .pipe(sourcemaps.write('_srcmap')) .pipe(gulp.dest('dist'));&#125;); 这里在sourcemaps.write()中传入了一个字符串_srcmap，用来指定Source Map即对照表的存储路径。 这样指定输出路径之后，文件编译转码完只会在最后一行只会写入对Source Map的文件引用，而Source Map对照表本身会被输出到指定的路径下： 1//@ sourceMappingURL=_srcmap/BearD01001.js.map 这样在开启浏览器开发者工具后，开发者工具就会自动去匹配Source Map了。 而生产线上则完全不用担心 谁会把Source Map文件放到生产线上？ 即使真的放上了，如果开发者工具未打开，浏览器也不会去加载这个文件。 静态文件的合并与压缩JS、CSS文件的合并压缩应该是产品上线前最常见的需求了。 不再需要你在各个JS/CSS压缩合并的工具中切来切去，也不需要你在各个IDE或是Editor中复制粘贴手动拼接合并，这些繁琐低效的工作正是Build System要帮你解决的！ 接下来要介绍的这几个插件都非常常用，也有许多文章介绍了使用方法，就不多加说明了，动动手搜一搜吧！ JS 的压缩插件 gulp-uglify 简介使用UglifyJS压缩JS文件 CSS 的压缩插件 gulp-clean-css ！注意！ 搜索CSS压缩工具的时候极有可能搜到gulp-minify-css，该插件已被弃用 简介使用clean-css压缩CSS文件 JS / CSS 的合并 JS或CSS文件的合并都是使用同一款插件gulp-concat。 插件 gulp-concat 简介合并JS或CSS文件 文件重命名上边介绍了静态文件的合并与压缩，通常合并或压缩之后我们都会给文件重命名一下，压缩后习惯重命名为FILENAME.min.js，合并后习惯重命名为all.js、main.css等等，这时就需要重命名插件来帮帮嘞~ 插件 gulp-rename 简介文件重命名 使用123456789101112131415161718var gulp = require('gulp');var rename = require('gulp-rename');// 可以这样简单粗暴的直接改名gulp.src('BearD01001.txt') .pipe(rename('BearD01010.md')) .pipe(gulp.dest('./')); // ./BearD01010.md// 也可以指定各种参数gulp.src('BearD01001.txt') .pipe(rename(&#123; dirname: 'text/markdown', basename: 'myself', prefix: 'introduce-', suffix: '-life', extname: '.md' &#125;)) .pipe(gulp.dest('./')); // ./text/markdown/introduce-myself-life.md 自动合并雪碧图插件 gulp-spriter 简介帮助前端工程师将css代码中的切片图片合并成雪碧图，支持retina图片。 NPM上有详细的中文使用介绍，不多介绍，简单好用 小图标转码为内联 base64插件 gulp-base64 简介将CSS中引用的小图标转码为base64编码的data URI字符串，减少额外的http请求数。 使用插件的使用非常简单，什么都不指定直接pipe到插件就OK了 1234567// 基础示例gulp.task('build', () =&gt; &#123; gulp.src('./css/*.css') .pipe(base64()) .pipe(concat('main.css')) .pipe(gulp.dest('./public/css'));&#125;); 当然也有简单但是十分好用的几个可选参数：123456789101112gulp.task('build', () =&gt; &#123; gulp.src('./css/*.css') .pipe(base64(&#123; baseDir: 'public', extensions: ['svg', 'png'], exclude: [/\.server\.(com|net)\/dynamic\//, '--live.jpg'], maxImageSize: 8*1024, // bytes debug: true &#125;)) .pipe(concat('main.css')) .pipe(gulp.dest('./public/css'));&#125;); 相信大家伙儿的英文都 OK，参数名称也很直观，就不加以说明啦Tips：在extensions参数中可以使用正则（例如：/\.jpg#datauri$/i）匹配带有指定 hash 的引用文件，这样在开发过程中就可以通过在文件末尾加上对应的hash（例如：background-image: url(./images/icon.jpg#datauri);）手动指定哪些文件转码成data URI嘞！ 构建异常捕获使用Gulp构建过程中一般会有JS、Less/SCSS编译转码的过程，这个过程是比较容易发生错误的，然鹅Gulp的默认做法是只要有插件抛出异常，那么整个Gulp的构建进程即停止运行。 也就是说即使出错后及时修正了错误并且保存了，还需要重新启动构建系统（即需要在CLI中重新输入gulp [TASKNAME]），这显然是很多余的一个步骤。 有没有什么方法在构建出错的时候不让构建进程break down呢？当然有！这就是Gulp官方推荐的构建插件之一gulp-plumber来做的事情，水管工，名字很贴切吧，哈哈~ 还有一个问题，如果Terminal窗口没在屏幕的可视范围内，构建出错了我不知道怎么办？傻傻地等着以为构建会完成等了半天发现没有任何反应？调出终端才发现构建失败了？这里就用到了另一个辅助插件gulp-util，可以用它在构建出错的时候让电脑 哔 ~ 的响一声，提示咱构建失败了赶紧debug！ 插件 gulp-plumber gulp-util 简介 gulp-plumber：构建异常捕获，防止构建进程崩掉 gulp-util：这个插件其实很强大哈，集合了许多Gulp中常用的小工具，例如log()、colors等等，这里只用到了beep()&amp;log，就是让电脑 哔 ~ 的响一声然后抛出异常，哈哈 使用1234567891011121314151617var gulp = require('gulp'), gutil = require('gulp-util'), babel = require('gulp-babel'), concat = require('gulp-concat'), plumber = require('gulp-plumber');gulp.task('build', () =&gt; &#123; gulp.src('./_src/js/*.js') // 最先 pipe 到 plumber 中，以便出现异常前准备捕获 .pipe(plumber(&#123; errHandler: e =&gt; &#123; gutil.beep(); // 哔~ 的响一声 gutil.log(e); // 抛出异常 &#125;&#125;)) .pipe(babel()) .pipe(concat('all.js')) .pipe(gulp.dest('./public/js'));&#125;); 使用 watch 插件提高构建效率gulp.src这个方法相信大伙儿都特别熟悉了，传入Glob来匹配并读取文档流，但是这个方法的缺点也很明显，就是会读取全部匹配的文件（即使文件未作修改），这样导致的一个明显问题就是： 随着项目的开发，文件越来越多，构建速度越来越慢。 当然，我们可以使用Gulp内置的watch方法来规避这个问题，不过这个方法有一个小问题不知道大家有没有发现，就是它检测不到新建文件的事件，感觉蛮不合理的。所以现在一般使用gulp-watch这个插件，这个插件可以自定义触发事件，而且通过插件提供回调机制配合大家熟悉的console可以很方便的观察到构建流程。 插件 gulp-watch 简介实时监测文件变化（可自定义触发事件与回调方法） 使用1234567891011121314var gulp = require('gulp'), watch = require('gulp-watch'), gutil = require('gulp-util'), moment = require('moment'), colors = require('colors');gulp.task('js', () =&gt; &#123; watch('./_src/js/*.js', (vinyl) =&gt; &#123; console.log(`[$&#123; moment().format('HH:mm:ss').gray &#125;] $&#123; vinyl.basename.yellow &#125; rebuilding.`); &#125;) .pipe(plugin1()) .pipe(plugin2()) .pipe(gulp.dest('./public/js'));&#125;); 通常的使用方法就是这样了，默认监测[&#39;add&#39;, &#39;change&#39;, &#39;unlink&#39;]通常是够用的，可以使用options.events来手动设置监测的事件类型。回调函数会在每次监测到事件时触发，可以通过参数vinyl对象取得文件的详细信息。前面的watch回调中实现了一个简单的构建流程监控，更完善的解决方案推荐使用 gulp-notify 其他提高构建体验的插件上边大伙儿可能注意到了，使用了gulp-moment与gulp-colors，这两个插件无关项目，纯属为了更好的监控构建状态引入的两个插件，下面简单介绍一下 插件 gulp-moment gulp-colors 简介 gulp-moment：相信不少小伙伴儿在browser-side用过moment.js这个工具，主要是进行时间方面的计算与格式化，官网有详细的介绍，使用起来很方便！ gulp-colors：这个是用来设置CLI输出文字的颜色的，只要在任意字符串后面使用，就可以改变输出到终端的文字颜色、样式。 使用 gulp-moment：moment().format(&#39;HH:mm:ss&#39;)格式化当前时间格式，其他参考官网文档； gulp-colors：&#39;*.html&#39;.yellow，任意字符串后面加上.+COLOR，即可改变颜色，项目主页有多种配色与样式可供选择。 好嘞，终于写完了，上边就是使用Gulp进行前端构建的常用方法与插件了，希望对你有所帮助。 如有问题，欢迎提出指正 就酱~ -END]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数式编程：柯里化的变型应用]]></title>
      <url>%2FJavaScript%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%8F%98%E5%9E%8B%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[函数柯里化不仅极大地提高了代码的可复用性与灵活性，而且降低了代码的耦合性，但是在生产环境中使用时发现了美中不足的一点，遂有此文，目的是改造柯里化函数结构，使之更方便使用、易于理解。 为方便理解，本篇文章虚拟了一个简单的业务场景：更新指定栏目下指定节目的描述信息 普通的函数柯里化首先，在变型前，一起看看大部分函数柯里化的实现与使用：123456789let updateProgramDesc = colunmID =&gt; &#123; return programID =&gt; &#123; desc =&gt; &#123; // do something... &#125; &#125;&#125;// 使用方法，更新 ID为10的栏目 下 ID为1000的节目 的描述信息为’description content.‘updateProgramDesc(10)(1000)('description content.'); 变型初衷使用时很明显，每一层的函数在传参的时候很容易让人产生困惑： 所使用的柯里化后的函数参数传到的哪一个层级？ 该传入哪个参数了？ 传入的这个参数是干什么的？ 尤其在柯里化程度较高的情况下这种困扰尤为明显，使用时经常需要仔细观察上下文，甚至是去查看原函数来确定传参：1func(param1)(param2)(param3)(param4)(param5)(param6); 柯里化的变型出于以上初衷，对柯里化函数的结构做了一些调整，如下：1234567891011let updateColumn = colunmID =&gt; &#123; return &#123; program(programID) &#123; return &#123; desc(desc) &#123; // do something... &#125; &#125; &#125; &#125;&#125; 发现哪里不同了吗？ 下面是变型后的使用方法：123456789101112131415// Fully chain calls.updateColunm(10).program(1000).desc('description content.');// Partial application invoke.let column = updateColunm(10);column .program(1001) .desc('update the description of program 1001 in column 100.');column .program(1002) .desc('update the description of program 1002 in column 100.');let program = column.program(1003);program.desc('update the description of program 1003 in column 100.');program.desc('update the new description of program 1003 in column 100.'); 优点 &amp; 不足优点通过return object代替function的方式，对象名可以非常恰当地对当前传参进行描述，使用时更清晰易懂，不易造成使用时确定传参困难、传参错误等情况。 其实实现思想很简单吧~ 不足不过这种方法也有一个不足之处就是会增加少量代码与缩进，不过可以尝试使用Promise来实现，会更优雅自然~ 进一步可能updateDesc(desc).ofProgram(programID).inColumn(columnID); 发现了吗？可以写出更贴近自然语言的柯里化函数！不过前文没有这么做，你知道是为什么吗？ 灵感来源jQuery的链式函数调用~ 参考文档： A Beginner’s Guide to Currying in Functional JavaScriptHigher-Order Functions in JavaScriptJavaScript函数柯里化的一些思考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端必备技能——本地服务器的搭建&配置]]></title>
      <url>%2FServer%2F%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA-%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[虽说各种前端 Build system 均有各自的静态服务器插件提供使用，但是每次使用均需要反复启动并长时间占用一个 Terminal 窗口，并不是很方便。 对于需要长期开发和维护的项目，搭建一个持续稳定的本地服务是很有必要的。 本篇文章就简单介绍一下本地服务器的搭建与配置。 这里推荐使用集成环境 XAMPP ，选择它的主要原因是因为有比较友好的控制面板哈，此外后端开发我目前一直在使用 PHP 。该集成环境 Windows、OS X、Linux 多平台持续更新哈~ 下载完对应平台的安装包我们就开始吧！ XAMPP 安装组件的选择 这里要简单讲一下 Windows 平台安装时的组件选择，Linux 用户可以跳过~，OS X 不太清楚哈 Apache 服务器组件是必选的哈，不介绍了。由于偶尔会写一点后端代码，所以我这里把 MySQL 数据库也装上了，下边的 PHPMyAdmin 是用来管理数据库的，这个集成环境的 PHP 也是必选的哈，目前已经更新到7.0.9了，据说比5快一倍2333~ FileZilla 是个 FTP 服务器、Mercury 是邮件服务器，含义简单明了，不过对于用来测试的本地服务器来说用处都不大。 Tomcat 如果有喜欢使用 JSP 的后端同学可以把 Tomcat 也勾选上~ Perl 通用脚本语言，这么火没用过肯定也听说过哈 Webbalizer 日志分析系统 Fake Sendmail 支持 PHP 发邮件的组件 组件选择完之后就可以一路 Next 下去嘞,直到安装完成 修改服务器根目录指向 依次点击 XAMPP 控制面板上 Apache 所在行后面的 Config → Apache (httpd.conf)，打开 Apache 主配置文件 httpd.conf。 这里主要讲一下本地服务器根目录的设置，将 DocumentRoot 与 Directory 的路径改为你常使用的工作目录，如这里改成‘D:/DinoWeb’。 该目录将作为服务器的根目录使用。默认情况下，在浏览器中输入 http://localhost 或 http://127.0.0.1 将直接访问到这个目录 Directory 中还有一些可选参数，简单介绍一下： Options：可选指令集，多个值以空格分隔，值前可用 ‘+’/‘-‘ 表示从父目录继承指令后对所继承指令的增删，可选值‘None’、‘All’或以下组合： Indexes - 无 index.html/index.htm/index.php 等文件时是否列出文件目录 FollowSymLinks - 在该目录中，服务器将跟踪符号链接 符号链接：Linux 系统中文件的快捷方式，在该目录中可以建立符号链接，以访问其他目录中的文件，配置此项以减少 Apache 调用其他系统函数检测符号链接。 Includes - 开启 SSI（即让 html 文件也支持相互 include） ExecCGI - 准许使用 CGI 更多… （偷个懒，其他就不写了哈~） AllowOverride：是否支持 url rewrite，值为 All 时则访问服务器时会读取目录下 .htaccess 文件以重写 url； 粗暴点解释就是：浏览器访问 a.html 文件通过 .htaccess 处理之后实际上给你的是 balabala.html 的内容，但浏览器地址栏中显示的还是 a.html，目录重写同理。 Require all granted/denied：是否允许访问。 虚拟主机的配置 为了更好地模拟真实的运行环境，一般推荐为每个项目配置一个独立的虚拟主机，而不是通过子目录的形式进行访问（例： http://localhost/myobject1 ），使用 http://myobject1.local 进行访问更加优雅自然~ 首先检查 httpd.conf 主配置文件中是否加载了虚拟主机配置文件，找到如下配置 1Include conf/extra/httpd-vhosts.conf 若该行使用‘#’号被注释，记得去掉‘#’号以加载虚拟主机配置文件。 然后配置httpd-vhosts.conf 依次点击 XAMPP 控制面板上 Apache 所在行后面的 Config → [Apache]，打开 Apache 所在文件夹，打开 /conf/extra 目录中的 httpd-vhosts.conf 虚拟主机配置文件。在文件末尾加上自己的虚拟主机配置： VirtualHost 指定了一个虚拟主机的 IP 地址与端口，端口默认为 80，IP 只要是内部回送地址就 OK，但不要用 127.0.0.1，这个是给根目录预留的哈，简单将一下其中的参数： Document 与 Directory 和根目录配置一样，指虚拟主机所指向的目录。这里在 Directory 中重写了可选命令‘-Indexes’，代表目录中没有索引文件的时候禁止显示文件列表； ServerName - 虚拟主机名称，备注一样的存在~ DirectoryIndex - 目录索引文件，就是首页入口 index.html、default.html 之类； ErrorLog - 异常日志 CustomLog - 使用 httpd.conf 中默认声明的 common 日志格式来记录访问日志（说白了就是普通的访问日志不必记录的那么详细，简单点记就够用了） 设置本地 Hosts 打开系统盘 /Windows/System32/drivers/etc 目录中的 Hosts 文件，在文件最末加上如下回送 IP 指向（类似小的 DNS 系统~）： 1127.0.0.2 hello.local 127.0.0.2 - 上文配置虚拟主机时 VirtualHost 的回送 IPhello.local - 虚拟域名（类似于 localhost，名称随你喜欢想怎么起就怎么起~） 将 Apache&amp;MySQL 安装为系统服务并启动 所有的配置完成后就可以启动服务了，点击每行 Action 中的 Start 即可启动！~(≧▽≦)/~ 推荐将 Apache 与 MySQL（如果你需要的话）安装为系统服务，这样每次系统启动的时候就会自动加载主机服务，免去了手动启动的麻烦，依次点击每行最前面的大红叉即可安装为系统服务。 赶紧写个栗子测试一下吧~ 写个 index.html 放入虚拟主机所在目录（即上文中的 D:/DinoWeb/HelloWorld） 直接在浏览器地址栏中输入 Hosts 配置中所填的虚拟域名（即上文的 http://hello.local ）即可直接访问！ 现在你已经有了一个自己配置的本地服务器了！赶快试一下吧！！为你的每个项目配置一个独立的虚拟主机~ OVER.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端必备技能——切图：进阶篇]]></title>
      <url>%2FPhotoshop%2F%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E2%80%94%E2%80%94%E5%88%87%E5%9B%BE%EF%BC%9A%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[现代互联网对交互设计越来越重视，切图早已经不是简单的使用 Photoshop 的切片工具对 JPG、PNG 等文件进行切片操作了。UI 设计师给出的设计稿往往会是 PSD 分层文件，这种文件中包含了更加丰富的图层、通道、路径等信息，也为更优雅的前端交互奠定了基础。 （OS：这句话的 Bigger 我给满分o(￣▽￣)d~ 自我陶醉中…） 今天就来讲一下使用 Photoshop 对 PSD 分层设计稿进行切图的具体操作，老鸟也可以看一下，没准儿会有意外的收获哈~准备： Photoshop CC （提取码：gb8x） PSD 设计稿（演示用稿：Navigation.psd） 开始： 打开设计稿 简单介绍一下主界面 ① 为画布、② 为工具栏、③ 为图层操作面板 加载 PSD 文件时可能会遇到嵌入的配置文件不匹配、字体丢失等问题，不用理会，直接按确定键即可。Tips：如果③图层工作区默认没有显示，点击 菜单栏&gt;窗口&gt;图层 即可打开 分析设计稿 分析设计稿有哪些内容是需要进行切图保留的内容，主要内容考虑主要有以下几个部分： ① 图标（是否可以使用伪元素 :before、:after 实现，例如各种箭头图标） ② 背景（是否可以使用 background 实现） ③ 按钮（是否可以使用 background、border-radius、:hover 等实现交互效果） ④ 字体（是否被高频使用，是否需要做成单独的字体文件或做成切片） ⑤ 装饰性元素（是否可以使用伪元素 :before、:after 实现） 现在我们来仔细分析一下这张设计稿： 图标 ② &amp; ④——这两部分都是图标，不同的是②这种简单的几何图标可以直接使用伪元素 :before、:after 来实现，不必做成图标切片；而④这种复杂的图标显然不能使用伪元素轻易画出来，这里鉴于图标数量较少可以直接做成单独切片或做成一张 Sprite 图。 P.S.这种纯色图标如果页面中使用率较高，可以考虑使用 Font Awesome 图标库 背景 ⑥ &amp; ⑧——⑧这类纯色/简单渐变的背景可以使用 CSS 直接实现；而⑥这类背景放大看可以发现他是有一定纹理的，这样的背景就只能进行切图了。 按钮 ①——这类按钮明显能使用 CSS 设计出来，用 CSS3 设置背景色的渐变打造光感、border-radius 设置按钮的圆角、.active &amp; :hover 状态类与伪类来实现交互效果。 字体 ③ &amp; ⑦——整体观察这个设计稿，大部分文字都是使用③的字体（高频使用），可以考虑把 UI 设计师使用的③字体做成 .woff 字体文件引入样式表中，或者直接使用通用的 Arial/sans-serif 字体（还原度会有所欠缺），至于⑦的字体，页面上使用率很低，只有页脚这一处用到，所以可以直接把⑦这里做成切片。 装饰性元素 ⑤——这种类似②这种简单的几何图标，但是仔细看有更丰富的光影与渐变效果，所以这里采用的是做成切片。 开始切图之前的分析主要是考虑哪些部分可以使用 CSS 实现，哪些部分只能使用切片。这需要较好的 CSS 知识储备，但还好 CSS 的门槛不高，稍加学习即可掌握。 开始切图 图标 拉几条参考线后可以很明显发现这类图标的大小都极其接近，这类图标可以切成同一尺寸方便使用，这里以第一个统计图标为例： Tips：参考线可以通过在主画板顶部及左侧的标尺中通过拖拽添加 / 删除，如果没有打开标尺，按快捷键 Ctrl+R 即可显示标尺。 通过右下角图层面板找到这个图标的所在图层，右键单击该图层非缩略图区域，选择‘转换为智能对象’；然后双击该图层的缩略图，进入该图标的智能对象画板窗口： 这时画布的大小正好是图标自身的大小（长宽像素不多不少）。 Tips：通常在导出前我会调整一下图标画布的大小，一般是长宽各加几个像素，这样做的目的是虽然前面看起来这些图标大小都差不多，但是其实大小一般是有所差别的（特别是高度），如果直接按照没调整之前的大小导出，很有可能会导致用 CSS 定位的时候发现各个图标垂直方向无法对齐，从而还需要额外对每个图标单独进行对齐，这显然是不合理的。 按快捷键 Ctrl+Alt+C 调整画布大小： 最好调整所加的像素数为偶数，这样画布在拓展的时候才能保证图标仍在画布中心位置。 调整好画布大小后，按快捷键 Ctrl+Alt+Shift+S（这个快捷键有点多，是时候考验一下手指的灵活性了(o´・ェ・｀o)），然后会弹出介个‘存储为 Web 所用格式’的窗口： 两个圈起来的地方，一个是选择导出格式：需要保留透明度的选择PNG-24（PNG-8不支持半透明，这是为了照顾 IE6 的显示效果，现在谁还管 IE6，用 IE6 的人还想要什么优雅的交互体验，页面能显示出来主要内容就不错了，嫌弃脸.jpg &lt;_&lt;），不需要保留透明度的选择JPEG。 选 PNG-24 记得勾选下方的‘交错’，选 JPEG 记得勾选‘连续’，这样在浏览器加载图片的时候会以模糊逐渐转为清晰的效果渐渐显示出来，浏览体验更好。 另一个是转换色彩空间：转换为 sRGB 可以在绝大部分浏览器中显示出你期望的颜色（涉及到图片的颜色配置管理，也是深坑，不多赘述）。 OK，其他选项都保持默认就好了，点击‘存储’，这样一个图标就‘切’好了！ 背景 放大看我们可以看到这个背景的纹理是由有序重复的图案组成的，首先我们还是按照操作图标的步骤来：找到对应图层&gt;转换为智能对象&gt;进入编辑智能对象画板。然后使用裁剪工具（快捷键 C），配合 Ctrl+‘+’ 放大画板，仔细裁剪出重复的最小单元： 最后同样 Ctrl+Alt+Shift+S 保存切片，这里由于该背景没有透明部分，所以保存格式选择 JPEG（即 .JPG 文件，相对于 PNG-24，对图片质量要求不高的情况下，JPEG 能获得更小的文件体积）。 现在这个网格背景的切片就搞定了！配合 background-repeat: repeat-x; 即可实现网格的背景效果！ Tips：这里如果想在使用背景切片之前确认一下最小重复单元的背景切片是否错位，可以点击 菜单栏&gt;定义图案 添加新图案，然后 Ctrl+N 新建一个与该背景切片高度相同，宽度较大一些的画板，然后 Shift+F5 打开填充对话框，‘内容&gt;使用’选择‘图案’，紧挨着下边的‘自定图案’选择刚刚添加的新图案，点击确认即可得到期望的背景，如果最小重复单元的切片出现错位等问题很容易发现，仔细重新裁剪一下就好啦~ 好嘞，切图的进阶篇就写到这里了，只讲了图标跟背景，其他部分大同小异哈（才不是因为懒 (¯﹃¯)，感兴趣的同学可以下载设计稿练练手哈。 写在最后： 实际现如今对PSD文件进行的操作已经不是简单的切图了， 但是鉴于最初确实是把整张JPG图片使用切片工具进行切成一个个小切片， 所以切图这种叫法一直沿用至今。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零开始：现在开始用ES6写代码]]></title>
      <url>%2FJavaScript%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B%E7%94%A8ES6%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[ES6（ECMAScript6.0）早在2015年便发布了第一个版本，所以又被称作ECMAScript2015。 作为已经正式发布的新版本，取代ES5是毋庸置疑的趋势，但鉴于浏览器的历史遗留问题，在生产线上我们还是需要一些工具来转换成ES5使其兼容旧版本的浏览器。下面来介绍一下使用Gulp+Babel进行ES6开发环境的部署： （操作很简单，写的比较详细所以字数比较多，别被吓退了哈，而且大部分配置都是一劳永逸，多个项目都可以通用，哈哈） 安装 NodeJS 既然使用Gulp跟Babel肯定少不了NodeJS，NodeJS各个平台均有对应的一键安装包，简单方便又省心！ 安装完成后打开命令行，分别输入 123$ npm -v$ node -v 出现如下输出就代表安装成功了（这里我用的是Git Bash，推荐使用，安装Git自带） 初始化NPM配置 在项目文件夹根目录，执行 1$ npm init 按照提示填好，除了name和version字段其他都是选填项，一路回车就OK了 最后项目根目录会出现一个package.json的配置文件，多数情况不会手动去修改，安装依赖时NodeJS会自动读写这个配置文件。 国内由于众所周知的原因NPM安装源访问的速度十分缓慢，建议使用如下命令更改为某宝的NPM镜像：$ npm config set registry https://registry.npm.taobao.org/ 安装 Gulp 首先 全局 安装Gulp 1$ npm install -g gulp 安装过程可能出现一些警告，不用理他，最后执行 1$ gulp -v 只要正确输出了版本号就OK了。 然后在项目根目录安装 开发依赖： 1$ npm install --save-dev gulp 许多小伙伴会疑惑这两种安装方法有什么差别，其实很简单，全局安装的一般是需要直接在命令行中使用的命令，比如这里的gulp：$ gulp taskName全局安装之后就可以直接在命令行中使用这样的命令来执行Gulp任务。而在项目根目录安装的开发依赖则是在项目根目录中的 node_modules 目录中放入模块的文件，可以直接在项目中通过require()来引入的模块。 安装 Gulp &amp; Babel 相关插件 首先安装 gulp-babel ： 1$ npm install --save-dev gulp-babel 安装转码包： 1$ npm install --save-dev babel-preset-latest 我这里安装了最新版本的转码包，这个转码包支持ES2017（Stage3）&amp;ES2016&amp;ES2015语法的转换。如果你只想使用正式推出的ES6（ES2015），则可以仅安装ES6的转码包：$ npm install --save-dev babel-preset-es2015 Babel转码配置： 1$ echo '&#123; "presets": ["latest"] &#125;' &gt; .babelrc 也可以手动在项目根目录创建 .babelrc 文件进行配置；仅转换ES6的小伙伴将命令中的 latest 换成 es2015 就OK了。 安装 gulp-watch： 1$ npm install --save-dev gulp-watch gulp-watch 用于实时监控文件变化实时编译文件，这样就不用每次写完代码再去手动运行gulp任务编译文件了，也是懒人必备！ 配置 Gulp 终于到最后一步了，哈哈，具体配置如下图，写了比较详细的注释了： 保存到项目根目录的 gulpfile.js 文件就好了。 最后在项目根目录执行： 1$ gulp 即可运行默认任务（任务名为 default） 赶快写个ES6语法试试吧~↖(^ω^)↗ 初入前端，粗写几字，如有不足，还望指正，谢谢。 共勉。 -END]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS简单小巧的时间日期格式转换函数]]></title>
      <url>%2FJavaScript%2FJS%E7%AE%80%E5%8D%95%E5%B0%8F%E5%B7%A7%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[JS简单小巧的时间日期格式转换函数 这是实现后的使用方法 1234567891011var now = new Date(); var nowStr = now.format('yyyy-MM-dd hh:mm:ss'); var testDate = new Date(); var testStr = testDate.format('YYYY年MM月dd日hh小时mm分ss秒'); alert(testStr); alert(new Date().format('yyyy年MM月dd日')); alert(new Date().format('MM/dd/yyyy')); alert(new Date().format('yyyyMMdd')); alert(new Date().format('yyyy-MM-dd hh:mm:ss')); 实现方法：在Date原型上添加方法 1234567891011121314151617181920212223242526272829Date.prototype.format = function(format) &#123; var o = &#123; 'M+': this.getMonth() + 1, //month 'd+': this.getDate(), //day 'h+': this.getHours(), //hour 'm+': this.getMinutes(), //minute 's+': this.getSeconds(), //second 'q+': Math.floor((this.getMonth() + 3) / 3), //quarter 'S': this.getMilliseconds() //millisecond &#125; if (/(y+)/.test(format)) &#123; format = format.replace( RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length) ); &#125; for (var k in o) &#123; if (new RegExp('(' + k + ')').test(format)) &#123; format = format.replace( RegExp.$1, RegExp.$1.length == 1 ? o[k]: ('00' + o[k]).substr(('' + o[k]).length) ); &#125; &#125; return format;&#125; (摘自网络，作者不详)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细数JavaScript中那些神乎其神的技巧]]></title>
      <url>%2FJavaScript%2F%E7%BB%86%E6%95%B0JavaScript%E4%B8%AD%E9%82%A3%E4%BA%9B%E7%A5%9E%E4%B9%8E%E5%85%B6%E7%A5%9E%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[闲来无事，整理一下JavaScript中那些神乎其神的技巧，假装大牛的样子 1. 字符串转换为数字123456var a = "123";console.log(+a); // 123console.log(typeof +a); // number// 同样可用于日期转换为数值：var b = +new Date(); // 1468545682168 2. 数值向下取整123var a = ~~3.14; // 3var b = 3.14&gt;&gt;0; // 3var c = 3.14|0; // 3 3. 字符串转换为数值并取整12var a = "3.14"|0; // 3var b = "3.14"^0; // 3 谢谢 @开始学习前端[kaishixuexiqianduan] 指正，该取整直接去除小数点后数字，仅对正数有效 4. 函数设置默认值1234function func(arg)&#123; var arg = arg || "default"; // arg 为 undefined, null, "", 0, false, NaN 时最后都得到"default"&#125; 5. 变量值交换12345var a = 1, b = 2;a = [b, b = a][0];console.log(a); // 2console.log(b); // 1 6. 使用for in遍历对象取到属性名与属性123456789var obj = &#123; a: 1, b: 2&#125;for(var i in obj) &#123; console.log("obj." + i + " = " + obj[i]);&#125;// output: obj.a = 1// obj.b = 2 7. 截断数组123var arr = [1, 2, 3, 4, 5, 6];arr.length = 3;console.log(arr); // [1, 2, 3] 8. 提高遍历较大Enumerable数据的性能123456789101112131415var arr = [1, 2, 3, 4, 5, 6, ...];var len = arr.length; // 缓存arr.lengthfor(var i = 0; i &lt; len; i++) &#123; console.log(arr[i]);&#125;// 也可将缓存写在for的声明中for(var i = 0, len = a.length; i &lt; len; i++) &#123; console.log(arr[i]);&#125;// 或者（！注意：若数组中键值存在undefined、null、0、false等数据时会中断遍历）for(var i = 0, a; a = arr[i++];) &#123; console.log(a);&#125; 9. 使用 &amp;&amp; 替代单一条件判断12345678// 你可能这样写过if(!token) &#123; login();&#125;// 其实这样也可以!token &amp;&amp; login();// 或token || login(); 10. 检测 对象/数组 中是否有指定 属性/元素123456789101112var CURD = &#123; add: function() &#123;&#125;, delete: function() &#123;&#125;, edit: function() &#123;&#125;&#125;console.log("add" in CURD); // trueconsole.log("find" in CURD); // false/* 误 */// var arr = [1, 2, 3];// console.log(1 in arr); // true// console.log(6 in arr); // false 谢谢 @zaaack[zaaack] 指正，数组的存在检测实质上是检测的是数组下标 11. 通过闭包调用setTimeout12345678910111213for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i); // 10 10 10 ... &#125;,500);&#125;for(var i = 0; i &lt; 10; i++) &#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); // 0 1 2 3 ... &#125;,500) &#125;)(i);&#125; 12. To be continue…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[好吧我很懒什么都没有弄_(:зゝ∠)_]]></title>
      <url>%2FOther%2F%E5%A5%BD%E5%90%A7%E6%88%91%E5%BE%88%E6%87%92%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E5%BC%84-%D0%B7%E3%82%9D%E2%88%A0%2F</url>
      <content type="text"><![CDATA[练练手，真的什么都没有写(:зゝ∠)]]></content>
    </entry>

    
  
  
</search>
